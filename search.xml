<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PVE+显卡直通历程</title>
      <link href="/2023/10/05/pve-li-cheng/"/>
      <url>/2023/10/05/pve-li-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p>机器：零刻SER5 Pro 5700U</p><p>系统环境：PVE 8.0 + Windows 11 专业版</p><p>本文参考视频：<a href="https://www.bilibili.com/video/BV1ZN411n74e">AMD核显直通显示输出</a></p><h1 id="安装PVE"><a href="#安装PVE" class="headerlink" title="安装PVE"></a>安装PVE</h1><p><a href="https://www.proxmox.com/en/downloads">PVE官方下载链接</a></p><p>下载最新的ISO Installer</p><p>ISO映像写入建议使用Etcher，简单快捷</p><p>安装过程没什么要写的，一路按需配置即可 Hostname 随意选择，写pve.lan就可以</p><p>然后登录PVE界面</p><h1 id="更换清华源"><a href="#更换清华源" class="headerlink" title="更换清华源"></a>更换清华源</h1><p>需要注意的是，PVE基于debian系统，因此清华镜像记得选debian</p><p>换源修改<code>/etc/apt/sources.list</code>，参考 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">清华debian官方文档</a>，<a href="https://mirrors.tuna.tsinghua.edu.cn/help/proxmox/">清华Proxmox官方文档</a>，<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ceph/">清华ceph官方文档</a></p><p>修改后，执行<code>sudo apt update</code>和<code>sudo apt upgrade</code></p><h1 id="修改DNS"><a href="#修改DNS" class="headerlink" title="修改DNS"></a>修改DNS</h1><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20231005155608535.png" alt="image-20231005155608535"></p><p>此处我选择的是阿里的公共DNS，修改DNS服务器2和DNS服务器3即可</p><p>然后使用<code>ping www.baidu.com</code>确定主机可以连接到外网，需要注意的是，PVE这个系统的ping命令很慢，要多等一会才会有显示</p><h1 id="编辑GRUB"><a href="#编辑GRUB" class="headerlink" title="编辑GRUB"></a>编辑GRUB</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nano</span> /etc/default/grub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在grub文件中在<code>GRUB_CMDLINE_LINUX_DEFAULT</code>选项中的<code>quiet</code>后面加上<code>initcall_blacklist=sysfb_init</code></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20231005160958121.png" alt="image-20231005160958121"></p><p>更新grub<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">update-grub</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>修改blacklist文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nano</span> /etc/modprobe.d/pve-blacklist.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在其后添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">blacklist amdgpublacklist i915blacklist snd_hda_inteloptions vfio_iommu_type1 <span class="token assign-left variable">allow_unsafe_interrupts</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>更新initramfs</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">update-initramfs -u -k all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新pcie设备</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">update-pciids<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示显卡的ID</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lspci -D -nn <span class="token operator">|</span> <span class="token function">grep</span> VGA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示声卡的ID</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lspci -D -nn <span class="token operator">|</span> <span class="token function">grep</span> Audio<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>记录下面的信息，到后面有用</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20231005161717463.png" alt="image-20231005161717463"></p><h1 id="提取VBIOS和GOP-Driver文件"><a href="#提取VBIOS和GOP-Driver文件" class="headerlink" title="提取VBIOS和GOP Driver文件"></a>提取VBIOS和GOP Driver文件</h1><p>使用AFUWIN软件，Windows PE进入主机中，提取出BIOS文件</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20231005164015286.png" alt="image-20231005164015286" style="zoom:80%;" /></p><p>可以用这个<a href="https://www.bilibili.com/read/cv17969975/">AFUWIN软件</a>，来提取BIOS文件，然后得到的就是一个这样的文件<code>afuwin.rom</code></p><p>将<code>afuwin.rom</code>文件放入UBU文件夹，运行UBU.bat</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20231005164738454.png" alt="image-20231005164738454" style="zoom:80%;" /></p><p>按任意键</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20231005164811701.png" alt="image-20231005164811701" style="zoom:80%;" /></p><p>输入2，回车</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20231005164846160.png" alt="image-20231005164846160" style="zoom:80%;" /></p><p>输入S，回车</p><p>而后就可以找到同文件夹中有一个Extract文件夹，里面有两个文件夹</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20231005165015242.png" alt="image-20231005165015242"></p><p>其中5000系列的VBIOS都是直接给出的，在VBIOS文件夹中。GOP Driver在GOP文件夹中。</p><p>下载<code>edk2-BaseTools-win32-master</code>软件，用cmd进入软件目录下，将<code>AMDGopDriver.efi</code>文件复制到软件目录下，运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">EfiRom.exe -f 0x1002 -i 0xffff -e AMDGopDriver.efi <span class="token comment">#注意，此处的0xffff中的ffff是显卡对应的设备号，例如此处应当是是164c。前面的0x1002中的1002代表AMD</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在同一文件夹下会出现<code>AMDGopDriver.rom</code>文件，将该 rom文件 和 VBIOS文件夹中的vbios文件 传送到服务器中，然后将该文件复制到<code>/usr/share/kvm</code>文件夹中，至此，准备工作已经完成，进入虚拟机安装程序。</p><h1 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h1><p>下载Windows11安装镜像，下载Virtio-win驱动并挂载，这个操作比较简单，不赘述。</p><p>在系统页面下，选择TPM，版本选择2.0，机型q35，显卡选择无。</p><p>磁盘总线选择SCIS，磁盘大小不小于64GB</p><p>CPU类别选择host效率更高，注意此处的核心指的是线程数量</p><p>网络模型选择 VirtIO(半虚拟化) 效率更高。</p><p>调整启动顺序，并添加CD/DVD驱动器的驱动iso文件</p><p>上述具体操作可参考文中开头的那个视频，做的比较详细</p><h1 id="GPU直通"><a href="#GPU直通" class="headerlink" title="GPU直通"></a>GPU直通</h1><p>添加PCI设备，选择到显卡对应的设备号，勾选 主GPU 和 PCI-Express </p><p>添加PCI设备，选择声卡设备号</p><p>添加USB键盘和鼠标，剩下来的东西后面再来添加。</p><h2 id="调整conf文件"><a href="#调整conf文件" class="headerlink" title="调整conf文件"></a>调整conf文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nano</span> /etc/pve/qemu-server/虚拟机序号.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调整romfile文件的指向：</p><p>在<code>hostpci0</code>后面加上<code>romfile=vbios文件名</code>，在<code>hostpci1</code>后面加上<code>romfile=AMDGopDriver.rom</code></p><p>运行<code>qm start 虚拟机序号</code>开机</p><p>此时即可见到屏幕亮起，完成系统的安装。</p><h1 id="亮屏之后"><a href="#亮屏之后" class="headerlink" title="亮屏之后"></a>亮屏之后</h1><p>记得安装Virtio的驱动程序，AMD核芯显卡的驱动需要自己进行安装，可能一开始不识别，但是只要屏幕亮了，就说明显卡直通成功了，GPU-Z会有显示的，打驱动即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器踩坑记</title>
      <link href="/2023/09/13/linux-fu-wu-qi-cai-keng-ji/"/>
      <url>/2023/09/13/linux-fu-wu-qi-cai-keng-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux服务器踩坑记"><a href="#Linux服务器踩坑记" class="headerlink" title="Linux服务器踩坑记"></a>Linux服务器踩坑记</h1><h2 id="Ubuntu的安装"><a href="#Ubuntu的安装" class="headerlink" title="Ubuntu的安装"></a>Ubuntu的安装</h2><p>在安装过程中，Ubuntu Server多次安装错误，解决方法是换一个u盘。。。</p><h2 id="DDNS服务"><a href="#DDNS服务" class="headerlink" title="DDNS服务"></a>DDNS服务</h2><p>DDNS服务选用的是园长给的教程，需要注意的是，DNS服务是有刷新时间的，有时候看上去没更新，实际上是DNS服务还在刷新中，等待即可。</p><p>学校的有线网是有IPv6的，而无线网是IPv4的。</p><p>首先的情况是，园长给的教程是<a href="https://iamddch.com.cn/2020/09/04/CloudflareBasedDDNS/">园长的DDNS教程</a>，其中给出的sh脚本存在一个问题，我在使用的时候无法对内网的ipv4地址进行同步，其报错内容为需要一个<code>valid ip address</code>，分析认为该脚本无法将内网ip地址上传至cloudflare服务器。而将ipv6地址进行同步的工作则较为顺利。</p><p>这就带来一个问题，我在校园网中是用不了ipv6的，而ipv4地址因为动态DHCP服务会一直改变，到后面远在上海的园长可以ssh上我的服务器，而在北京的我却要找园长<code>ifconfig</code>一下才能拿到本机的内网ipv4地址。</p><p>于是乎我以试试看的心态上网找了另外一个DDNS脚本，即<a href="https://github.com/wherelse/cloudflare-ddns-script/tree/master">DDNS脚本</a>，运行后效果良好，能够正确的将本地ipv4地址同步至cloudflare。</p><p>DDNS服务器脚本是有问题的，明天需要改一下脚本的内容，然后综合到se.yyhnet.top里面去</p><p>最后使用<a href="https://github.com/NewFuture/DDNS">ddns整合包</a>解决了问题，然后写了一个bash放进crontab里面设置为定时任务。写了一个命令以获得内网ip地址<code>ifconfig enp1s0 | grep &#39;inet &#39; | awk &#39;&#123;print $2&#125;&#39;</code>解析一下：首先是调出了网卡enp1s0的所有信息，而后选择inet （记得inet后面有个空格）的这一行，awk即选择字段2，就可以得到inet后面的ip地址</p><h3 id="整合包教程"><a href="#整合包教程" class="headerlink" title="整合包教程"></a>整合包教程</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> pip <span class="token comment">#安装pip</span>pip <span class="token function">install</span> ddns <span class="token comment">#用pip安装ddns</span><span class="token builtin class-name">cd</span> 你想进入的文件夹<span class="token function">mkdir</span> ddns <span class="token comment">#建立ddns文件夹</span>ddns <span class="token comment">#运行ddns，然后会出现config.json文件</span><span class="token function">vim</span> config.json <span class="token comment">#编辑config.json文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数配置表：<br>|  key   |        type        | required |   default   |    description    | tips                                                                                                        |<br>| :——: | :————————: | :———: | :————-: | :———————-: | —————————————————————————————————————————————————————- |<br>|   id   |       string       |    √     |     无      |    api 访问 ID    | Cloudflare 为邮箱(使用 Token 时留空)<br>HE.net 可留空                                                       |<br>| token  |       string       |    √     |     无      |  api 授权 token   | 部分平台叫 secret key , <strong>反馈粘贴时删除</strong>                                                                  |<br>|  dns   |       string       |    No    | <code>&quot;dnspod&quot;</code>  |    dns 服务商     | 阿里 DNS 为<code>alidns</code>,<br>Cloudflare 为 <code>cloudflare</code>,<br>dns.com 为 <code>dnscom</code>,<br>DNSPOD 国内为 <code>dnspod</code>,<br>DNSPOD 国际版为 <code>dnspod_com</code>,<br>HE.net 为<code>he</code>,<br>华为 DNS 为<code>huaweidns</code>,<br>自定义回调为<code>callback</code> |<br>|  ipv4  |       array        |    No    |    <code>[]</code>     |   ipv4 域名列表   | 为<code>[]</code>时,不会获取和更新 IPv4 地址                                                                           |<br>|  ipv6  |       array        |    No    |    <code>[]</code>     |   ipv6 域名列表   | 为<code>[]</code>时,不会获取和更新 IPv6 地址                                                                           |<br>| index4 | string|int|array |    No    | <code>&quot;default&quot;</code> |   ipv4 获取方式   | 可设置<code>网卡</code>,<code>内网</code>,<code>公网</code>,<code>正则</code>等方式                                                                     |<br>| index6 | string|int|array |    No    | <code>&quot;default&quot;</code> |   ipv6 获取方式   | 可设置<code>网卡</code>,<code>内网</code>,<code>公网</code>,<code>正则</code>等方式                                                                     |<br>|  ttl   |       number       |    No    |   <code>null</code>    | DNS 解析 TTL 时间 | 不设置采用 DNS 默认策略                                                                                     |<br>| proxy  |       string       |    No    |     无      | http 代理<code>;</code>分割  | 多代理逐个尝试直到成功,<code>DIRECT</code>为直连                                                                       |<br>| debug  |        bool        |    No    |   <code>false</code>   |   是否开启调试    | 运行异常时,打开调试输出,方便诊断错误                                                                        |<br>| cache  |    string|bool    |    No    |   <code>true</code>    |   是否缓存记录    | 正常情况打开避免频繁更新,默认位置为临时目录下<code>ddns.cache</code>,<br>也可以指定一个具体文件实现自定义文件缓存位置         |</p><h2 id="未解之谜"><a href="#未解之谜" class="headerlink" title="未解之谜"></a>未解之谜</h2><p>我的机器物理内存是8G，但是<code>free -g</code>命令之后得到的总空间只有4G，暂时还是不明白原因</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230909194642717.png" alt="image-20230909194642717"></p><h3 id="未解之谜的解决"><a href="#未解之谜的解决" class="headerlink" title="未解之谜的解决"></a>未解之谜的解决</h3><p>园长发现，缺失的ram应该是分配给了gpu用作核显显存</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230909224149495.png" alt="image-20230909224149495" style="zoom:80%;" /></p><h2 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h2><p>定时执行可以使用<code>crontab -e</code>，具体使用方法参考<a href="https://www.runoob.com/linux/linux-comm-crontab.html">菜鸟教程</a></p><p>常见的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">*/5 * * * * /home/yyh/test.sh  <span class="token comment">#每五分钟执行一次test.sh</span>* */2 * * * /sbin/service httpd restart <span class="token comment">#每两个小时重启一次apache</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>ifconfig</code>查看当前机器网络状态，按网卡分类</p><h3 id="iperf3是个好工具"><a href="#iperf3是个好工具" class="headerlink" title="iperf3是个好工具"></a>iperf3是个好工具</h3><p><code>iperf3 -s</code>当前机器作为服务端</p><p><code>iperf3 -c ipaddress</code> 当前机器作为客户端，对特定ip地址进行网速测试</p><p><code>-p port</code>指定端口</p><h2 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h2><p>脚本文件必须要<code>chmod +x</code>将权限调整之后才能进行运行，<code>chmod 777</code>也行</p><p>登陆的端口已经改成35791了，在ssh后面需要加<code>-p 35791</code></p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>园长已经为系统设置防火墙，故刚才的iperf3的速度测试打不出来速度</p><p><code>ufw status</code> 查看开放的端口</p><p><code>ufw allow xxx</code> 打开端口xxx</p><p><code>ufw delete allow xxx</code> 关闭端口xxx</p><p><code>ufw enable</code> 防火墙打开</p><p><code>ufw disable</code> 防火墙关闭</p><h2 id="猫猫"><a href="#猫猫" class="headerlink" title="猫猫"></a>猫猫</h2><p>想在linux养一只猫猫，养猫教程目前参考的这篇<a href="https://blog.zzsqwq.cn/posts/how-to-use-clash-on-linux/">养猫</a></p><h3 id="解压问题"><a href="#解压问题" class="headerlink" title="解压问题"></a>解压问题</h3><p>对<code>.gz</code>文件的解压，使用<code>gzip -d xxx.gz</code>，对<code>.tar</code>文件的解压，使用<code>tar -xf xxx.tar</code>，对<code>tar.gz</code>或<code>.tgz</code>文件的解压，使用<code>tar -xzf xxx.tgz/xxx.tar.gz</code>具体参见<a href="https://www.runoob.com/w3cnote/linux-tar-gz.html">菜鸟教程</a></p><h3 id="挂载U盘问题"><a href="#挂载U盘问题" class="headerlink" title="挂载U盘问题"></a>挂载U盘问题</h3><p>查看目前系统的挂载情况<code>fdisk -l</code></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230910105646867.png" alt="运行结果" style="zoom:80%;" /></p><p>此处挂载的应该是分区，而不是设备id，即应当选择挂载/dev/sdb1而不是挂载/dev/sdb</p><p>挂载命令：<code>mount /dev/sdb1 /dev/usb</code> 需要注意的是，若dev目录下没有usb文件夹，则需要先手动<code>mkdir /dev/usb</code>，再进行挂载</p><p>取消挂载命令：<code>umount /dev/sdb1</code></p><h3 id="docker问题"><a href="#docker问题" class="headerlink" title="docker问题"></a>docker问题</h3><p>没啥好讲的，参考的这篇<a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">docker教程</a></p><h2 id="Seafile部署"><a href="#Seafile部署" class="headerlink" title="Seafile部署"></a>Seafile部署</h2><p>养猫去了把这茬给忘了，下次再写</p><p>使用docker部署Seafile服务器，参考的是官方文档<a href="https://cloud.seafile.com/published/seafile-manual-cn/docker/用Docker部署Seafile.md">用Docker部署Seafile</a>，因此学习了一些Docker的基本命令。目前已经在服务器上部署了seafile服务，登陆账户和注册账户已经可以跑了，但是暂时还没搭建数据库，存不了东西。</p><p>发现不是数据库的问题，使web端的seafile地址没设置好，下图需要设置成自己的URL才能够存放文件<img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230912173209371.png" alt="image-20230912173209371"></p><p>现在的问题是只有http而没有https证书，等会需要问一下园长有没有搭nginx，考虑走nginx</p><h3 id="docker的相关命令"><a href="#docker的相关命令" class="headerlink" title="docker的相关命令"></a>docker的相关命令</h3><p>可参考<a href="https://www.runoob.com/docker/docker-container-usage.html">菜鸟教程</a></p><p>列出本地镜像 <code>docker images</code></p><p>列出所有本地镜像的状态 <code>docker ps -a</code></p><p>列出xxx的本地镜像 <code>docker images xxx</code></p><p>启动已经停止运行的容器 <code>docker start ContainerID</code></p><p>停止一个容器 <code>docker stop ContainerID</code></p><p>删除一个容器 <code>docker rm -f ContainerID</code></p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是一个反向代理服务，我在服务器中的使用是：外部主机域名访问24680端口时，会重定向到本机的80端口，并进行https加密</p><p>园长将Nginx安装于<code>/usr/local/nginx</code>位置，其中需要注意的是<code>conf</code>文件夹和<code>sbin</code>文件夹，<code>conf</code>文件夹中的<code>nginx.conf</code>是nginx的配置文件，<code>sbin</code>文件夹中的<code>nginx</code>是nginx程序的执行文件</p><h3 id="普通反向代理"><a href="#普通反向代理" class="headerlink" title="普通反向代理"></a>普通反向代理</h3><p>具体教程可以看<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html">程序员自由之路</a>，常用功能简单说明一下</p><p>nginx.conf文件分为三个部分：全局块、event块、http块</p><p>例子：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#全局块</span><span class="token comment">#user  nobody;</span>worker_processes  <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">#event块</span>events <span class="token punctuation">&#123;</span>    worker_connections  <span class="token number">1024</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">#http块</span>http <span class="token punctuation">&#123;</span>    <span class="token comment">#http全局块</span>    keepalive_timeout  <span class="token number">65</span><span class="token punctuation">;</span>    <span class="token comment">#server块</span>    server <span class="token punctuation">&#123;</span>        <span class="token comment">#server全局块</span>        listen       <span class="token number">8000</span><span class="token punctuation">;</span>        server_name  localhost<span class="token punctuation">;</span>        <span class="token comment">#location块</span>        location / <span class="token punctuation">&#123;</span>            root   html<span class="token punctuation">;</span>            index  index.html index.htm<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        error_page   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html<span class="token punctuation">;</span>        location <span class="token operator">=</span> /50x.html <span class="token punctuation">&#123;</span>            root   html<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">#这边可以有多个server块</span>    server <span class="token punctuation">&#123;</span>      <span class="token punctuation">..</span>.    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>做反向代理需要考虑的是http块，http块由http全局块和server块构成，重要的是server块</p><p>一个最简单的无加密的反向代理server块如下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen listen_port<span class="token punctuation">;</span><span class="token comment">#监听端口</span>server_name xxx.xxx.xxx<span class="token punctuation">;</span><span class="token comment">#域名，没有域名的话也可以不写</span>client_max_body_size 10000m<span class="token punctuation">;</span><span class="token comment">#这里极为重要，因为nginx默认是设置最大文件传输大小为1m，如果不改变的话传输的时候就会卡死</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://127.0.0.1:proxied_port<span class="token punctuation">;</span><span class="token comment">#被反向代理的端口服务</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HTTPS加密"><a href="#HTTPS加密" class="headerlink" title="HTTPS加密"></a>HTTPS加密</h3><p>https加密我这里使用的是certbot，参考的是<a href="https://kuokuo.io/2019/08/05/get-lets-encrypt-cert/">Cerbot教程</a>。Certbot是Let’s Encrypt的官方推荐证书申请工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> certbot<span class="token comment">#安装Certbot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> certbot -h <span class="token comment">#看输出，以确定Certbot已经安装完毕</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭80端口和443端口的程序</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">lsof</span> -i:port<span class="token comment">#查看端口号占用情况，然后kill或者用其他方法关闭</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>无静态目录的做法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> certbot certonly --standalone -d example1.com -d example2.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有静态目录的做法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> certbot certonly --webroot -w /var/www/example -d example.com -d www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时会要求输入邮箱，运行结束后需要记下证书的存放位置，例如</p><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230913114416105.png" alt="image-20230913114416105"></p><p>接下来进入nginx.conf文件进行配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>        server_name example.com www.example.com<span class="token punctuation">;</span>        listen <span class="token number">443</span> ssl<span class="token punctuation">;</span><span class="token comment">#设置为ssl</span>        listen <span class="token punctuation">[</span>::<span class="token punctuation">]</span>:443 ssl<span class="token punctuation">;</span><span class="token comment">#注意，nginx默认的方式是只监听ipv4的端口，如果想监听ipv6的端口那必须以这种方式[::]:port写出来</span>        <span class="token comment"># ssl on; ssl on这个方法已经被废弃，现在只需要在listen后面加ssl即可</span>        ssl_certificate 路径/fullchain.pem<span class="token punctuation">;</span>        ssl_certificate_key 路径/privkey.pem<span class="token punctuation">;</span>client_max_body_size 10000m<span class="token punctuation">;</span><span class="token comment">#这里极为重要，因为nginx默认是设置最大文件传输大小为1m，如果不改变的话传输的时候就会卡死</span>        location / <span class="token punctuation">&#123;</span>           proxy_pass http://127.0.0.1:proxied_port<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>退出保存，进入nginx的sbin文件夹，然后重启nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ./nginx -t<span class="token comment">#查看测试代码，如果successful就可以重启</span><span class="token function">sudo</span> ./nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>nginx命令也就那么几条</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -t <span class="token comment">#测试nginx.conf文件是否可用</span>nginx -s reload <span class="token comment">#重新载入配置文件并运行</span>nginx -s stop <span class="token comment">#快速停止nginx</span>nginx -s quit <span class="token comment">#停止nginx（推荐）</span>nginx -v <span class="token comment">#查看nginx版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="虚拟化（现在已经在用PVE了）"><a href="#虚拟化（现在已经在用PVE了）" class="headerlink" title="虚拟化（现在已经在用PVE了）"></a>虚拟化（现在已经在用PVE了）</h2><p>折腾了一下午，终于实现了Windows10在Ubuntu Server下的虚拟化运行，目前配置为双核四线程，CPU性能损失很小，GPU似乎暂时存在兼容性问题，待处理</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>参考文章：<a href="https://cloud-atlas.readthedocs.io/zh_CN/latest/kvm/install/ubuntu_deploy_kvm.html">KVM-Atlas</a>、<a href="https://zhuanlan.zhihu.com/p/24764017">在 Ubuntu 的 KVM 中安装 Windows 系统</a>、<a href="https://hsinin.github.io/2017/01/16/KVM-Qemu-Libvirt%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/">KVM-Qemu-Libvirt三者之间的关系</a>、<a href="https://www.cnblogs.com/cyleon/p/9816989.html">virsh常用命令</a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">egrep</span> -c <span class="token string">'(vmx|svm)'</span> /proc/cpuinfo <span class="token comment">#查看CPU是否支持虚拟化技术，输出0表示不支持</span>$ <span class="token function">egrep</span> -c <span class="token string">' lm '</span> /proc/cpuinfo <span class="token comment">#大于0则为64位处理器</span>$ <span class="token function">uname</span> -m <span class="token comment">#检查内核，若x86_64则为64位内核</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="安装KVM"><a href="#安装KVM" class="headerlink" title="安装KVM"></a>安装KVM</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst <span class="token comment">#我也说为什么安装的时候有red hat的表示，原来此处的virt-install就是red hat提供的</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h3><p>这一步不知道有什么用，反正加进去就完事了，如果用户权限这块出了问题就去找这个<a href="https://cloud-atlas.readthedocs.io/zh_CN/latest/kvm/install/ubuntu_deploy_kvm.html">Ubuntu部署KVM</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> adduser <span class="token variable"><span class="token variable">`</span><span class="token function">id</span> -un<span class="token variable">`</span></span> libvirt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建Windows虚拟机"><a href="#创建Windows虚拟机" class="headerlink" title="创建Windows虚拟机"></a>创建Windows虚拟机</h3><p>大坑要来了</p><p>创建虚拟机配置文件的写法（此处我将virt-install命令写成了一个脚本文件，所以称之为配置文件，实际上与直接输入virt-install命令没有区别）</p><p>virtio驱动文件的下载地址<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/">fedora</a>，建议使用iso文件</p><p>qcow2文件和raw文件的区别可以参考<a href="https://blog.csdn.net/sssssuuuuu666/article/details/106999198">KVM-qcow2和raw格式对比</a></p><p>注意virtio.iso文件必须在—disk中以cdrom格式挂载，这里我折腾了好久才挂上</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>virt-install <span class="token punctuation">\</span>  --network <span class="token assign-left variable">bridge</span><span class="token operator">=</span>virbr0,model<span class="token operator">=</span>virtio <span class="token punctuation">\</span> <span class="token comment">#网络连接方式</span>  --name win10 <span class="token punctuation">\</span>   --ram <span class="token number">2048</span> <span class="token punctuation">\</span> <span class="token comment">#内存大小，单位为MB</span>  --vcpus <span class="token assign-left variable">sockets</span><span class="token operator">=</span><span class="token number">1</span>,cores<span class="token operator">=</span><span class="token number">2</span>,threads<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">\</span> <span class="token comment">#分配的cpu数量，此处的threads指的是每个核分配的线程数，类似这里cores=2,threads=2，到最后的vpcu就会等于2*2=4 </span>  --os-variant<span class="token operator">=</span>win10 <span class="token punctuation">\</span>  --disk <span class="token assign-left variable">path</span><span class="token operator">=</span>/var/lib/libvirt/images/vir-driver.iso,device<span class="token operator">=</span>cdrom<span class="token punctuation">\</span> <span class="token comment">#驱动文件virtIO.iso的挂载。iso文件应当以cdrom方式挂载，且当主硬盘格式为qcow2时，必须在安装前挂载该virtIO-win驱动，否则会导致安装时系统无法识别主硬盘</span>  --disk <span class="token assign-left variable">path</span><span class="token operator">=</span>/var/lib/libvirt/images/win10.qcow2,format<span class="token operator">=</span>qcow2,bus<span class="token operator">=</span>virtio,cache<span class="token operator">=</span>none,size<span class="token operator">=</span><span class="token number">40</span> <span class="token punctuation">\</span> <span class="token comment">#主硬盘挂载。任意选择一个地方放至该qcow2文件即可，文件系统建议选择qcow2，因为其空间要比raw好很多，size后面指的是主硬盘空间大小，单位为GB。</span>  --graphics spice <span class="token punctuation">\</span> <span class="token comment">#远程桌面连接协议，此处可选vnc和spice，建议选择spice，流畅度好很多，但是选择了spice之后似乎就不能指定端口了</span>  --cdrom /var/lib/libvirt/images/win10_ltsc.iso <span class="token comment">#系统镜像文件，以cdrom的形式挂载</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若创建成功，则会有如下显示</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230914180946439.png" alt="image-20230914180946439" style="zoom:80%;" /></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Starting install<span class="token punctuation">..</span>.Creating domain<span class="token punctuation">..</span>.Domain installation still <span class="token keyword">in</span> progress. Waiting <span class="token keyword">for</span> installation to complete.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="远程端口映射到本地"><a href="#远程端口映射到本地" class="headerlink" title="远程端口映射到本地"></a>远程端口映射到本地</h3><p>不知道为什么这些远程桌面软件都要求对远程端口进行本地映射，也就是要求其只能连接127.0.0.1:ports</p><p>需要注意，此处的远程端口映射到本地指的是在客户端进行操作，即输入shell的是客户端，绝对不是服务器！！！！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -C -L local_port:127.0.0.1:remote_port username@server.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用的是spice协议，则其默认端口为5900，即此处的remote_port为5900</p><p>运行后会让输入对应用户的密码，然后ssh登录，往前面翻看是否有报错，没有的话不要关闭这个窗口，到后台最小化即可</p><h3 id="选用远程桌面"><a href="#选用远程桌面" class="headerlink" title="选用远程桌面"></a>选用远程桌面</h3><p>我首先选用的是windows自带的桌面，由于虚拟机使用的是spice协议，而windows自带的远程桌面使用的是RDP协议，所以无法进行连接，后续可以考虑用这个。安装期间使用的是virt-viewer，下载链接是<a href="https://virt-manager.org/download.html">virt-viewer</a>，windows版本藏在一堆文字里，要仔细找。</p><p>virt-viewer这个软件倒是傻瓜式操作，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spice://127.0.0.1:5900<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可看到安装界面。</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230914224003561.png" alt="image-20230914224003561" style="zoom:80%;" /></p><h3 id="Windows驱动安装"><a href="#Windows驱动安装" class="headerlink" title="Windows驱动安装"></a>Windows驱动安装</h3><p>在安装windows之前必须先安装驱动，否则系统无法识别主硬盘。这里如果之前的virtio.iso文件安装正确的话，可以很顺利地安装驱动。</p><p>在windows安装完成后，记得还要去磁盘驱动器安装驱动。</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230914225308072.png" alt="image-20230914225308072"></p><h3 id="KVM虚拟机的命令"><a href="#KVM虚拟机的命令" class="headerlink" title="KVM虚拟机的命令"></a>KVM虚拟机的命令</h3><p>KVM使用virsh进行操作</p><p><code>virsh list</code> 显示正在运行的虚拟机</p><p><code>virsh list --all</code> 显示所有虚拟机</p><p><code>virsh strat vmname</code> 启动vmname虚拟机</p><p><code>virsh stop vmname</code> 关闭vmname虚拟机</p><p><code>virsh destroy vmname</code> 给vmname强制断电</p><p><code>virsh suspend vmname</code> 暂停虚拟机</p><p><code>virsh resume vmname</code> 恢复挂起的虚拟机</p><p><code>virsh undefine vmname</code> 删除vmname虚拟机</p><p><code>virsh edit vmname</code> 修改vmname的配置文件</p><h3 id="KVM虚拟机配置文件"><a href="#KVM虚拟机配置文件" class="headerlink" title="KVM虚拟机配置文件"></a>KVM虚拟机配置文件</h3><p>在虚拟机已经创建后还可以对虚拟机的配置进行修改。配置文件的具体含义参见<a href="https://blog.51cto.com/sunshyfangtian/679964">KVM虚拟机的xml配置文件</a></p><p>这里的坑是vcpu的值一定要是threads和cores的乘积。</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/Snipaste_2023-09-14_23-44-51.png" alt="Snipaste_2023-09-14_23-44-51" style="zoom:80%;" /></p><p>报错如下：</p><p><code>error: unsupported configuration: CPU topology doesn&#39;t match maximum vcpu count</code></p><p>坑：本地端口映射到远程、创建虚拟机配置文件的写法（virt-install命令的写法、virtIO驱动的下载、virtIO驱动cdrom的挂载、Graphic中spice和vnc的选择、cpu核心数和线程数中线程对应的是总线程数还是每个core的线程数、各种kvm文件系统的区别）、KVM虚拟机的创建、启动、停止、删除、运行时虚拟机配置文件的写法（在虚拟机创建后还可以调整虚拟机的配置、vcpu的限制）、远程桌面的使用（windows自带的远程桌面、tight VNC、virt-manager，spice和vnc协议的选择）</p><p>报错：</p><p><code>error: unsupported configuration: CPU topology doesn&#39;t match maximum vcpu count</code></p><p>需要理解的：QEMU、KVM、Libvir、virsh关系和区别</p><p>仍需学习：虚拟机克隆</p><h2 id="北交校园网"><a href="#北交校园网" class="headerlink" title="北交校园网"></a>北交校园网</h2><p>登录<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token string">'http://10.10.43.3'</span> --data <span class="token string">"DDDDD=student_id&amp;upass=password&amp;0MKKey="</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>登出<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token string">'http://10.10.43.3/F.htm'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code C++编译运行教程</title>
      <link href="/2022/06/07/vs-code-c-bian-yi-yun-xing-jiao-cheng/"/>
      <url>/2022/06/07/vs-code-c-bian-yi-yun-xing-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="VS-Code-C-编译运行教程"><a href="#VS-Code-C-编译运行教程" class="headerlink" title="VS Code C++编译运行教程"></a>VS Code C++编译运行教程</h1><p>基于<a href="https://zhuanlan.zhihu.com/p/77074009教程，加上我的做法">https://zhuanlan.zhihu.com/p/77074009教程，加上我的做法</a></p><h2 id="Mingw安装"><a href="#Mingw安装" class="headerlink" title="Mingw安装"></a>Mingw安装</h2><p><a href="https://sourceforge.net/projects/mingw-w64/files/">https://sourceforge.net/projects/mingw-w64/files/</a> 在这里下载Mingw的最新版本，记得下载下面的MinGW-W64 GCC</p><p>而后将Mingw放入一个位置，然后配置环境变量即可，此处不赘述</p><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><h3 id="VSCode-插件安装"><a href="#VSCode-插件安装" class="headerlink" title="VSCode 插件安装"></a>VSCode 插件安装</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230607223425182.png" alt="image-20230607223425182"></p><h3 id="配置文件处理"><a href="#配置文件处理" class="headerlink" title="配置文件处理"></a>配置文件处理</h3><p>这个是最重要的，有三个配置文件需要进行配置</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230607223702763.png" alt="image-20230607223702763"></p><h4 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h4><p>该文件可由VScode自动生成，生成方式为</p><ol><li>同时按<strong>Ctrl</strong> +<strong>Shift</strong>+<strong>P</strong>，打开命令面板，输入C/C++，选择<strong>编辑配置 (UI)</strong>或者<strong>Edit Configurations (UI)</strong>。</li><li>其中<strong>编辑器路径</strong>根据需要修改为mingw的gcc.exe或g++.exe，<strong>IntelliSense模式</strong>修改为windows-gcc-x64，</li><li>关闭窗口，<strong>c_cpp_properties.json</strong>文件会自动生成</li></ol><h4 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h4><p>这个文件博大精深，首先我们要谈一谈编译和运行这两个概念，Vscode中编译和运行实际上是能分开的</p><p>编译最简单的方法莫过于命令行，<code>g++ test.cpp -o test.exe</code>这是一个非常简单的编译命令，然而，我们也可以使用<strong>终端</strong>中的任务来进行将编译这一过程自动化。</p><p>在.vscode文件夹不存在tasks.json文件时，选择运行，然后调试，其会出现<img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230607231054335.png" alt="image-20230607231054335"></p><p>选择生成和调试活动文件即可，而实际上这个选项本来就在终端的 配置任务 之中（如下图）。<img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230607231446417.png" alt="image-20230607231446417"></p><p>打开后，会自动生成tasks.json文件</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230607231528748.png" alt="image-20230607231528748"></p><p>上述tasks.json完成的就是编译程序的任务，其中type这个选项是可以去掉的，然后label可以对task进行修改，一个tasks文件可以有多个task，在tasks的打括号后面加上逗号，再加上大括号即可。</p><p>当对多个文件进行编译时，可以在args中插入该文件的位置，例如<code>$&#123;fileDirname&#125;\\cJSON.c</code>，非常灵活。</p><h4 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h4><p>该文件在运行和调试中自动生成</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230607232028469.png" alt="image-20230607232028469"></p><p>创建后可在右下角添加配置，选择启动即可，Bash启动没看懂是啥，暂时不用。</p><p>需要修改的大概是两处地方，program和miDebuggerPath，program修改为<code>$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.exe</code>，需要注意program可灵活修改，miDebuggerPath修改为对应的mingw文件夹下的bin文件夹中的gdb.exe文件。</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230607232425865.png" alt="image-20230607232425865"></p><h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><p>配置完成后，即可进行编译与运行，点击终端，其中的运行任务中就会有编译的task，然后运行点击运行中的非调试运行即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二战日记</title>
      <link href="/2022/03/29/er-zhan-ri-ji/"/>
      <url>/2022/03/29/er-zhan-ri-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="3-29"><a href="#3-29" class="headerlink" title="3-29"></a>3-29</h2><p>第一天写二战日记了，希望每天都能坚持</p><p>4月1号大概和胡酱聊一下408的相关复习方案，现在408复习主要还是以王道为主，感觉学习压力并不大，不过数学也要搞得去了。还是不要一心两用。</p><p>英语大概每天也就背背单词吧，英语这块比较有信心，政治大概8月份开始吧，现在还不着急。</p><p>今天408这块把VScode的环境配置了一下，代码结构差不多理清楚了，明天要写不少线性表的算法。</p><h2 id="3-30"><a href="#3-30" class="headerlink" title="3-30"></a>3-30</h2><p>写了四道算法题，单词还没背完。。。。</p><p>大概以后就用VScode做算法题了，VS总要把源文件排除到项目之外，很麻烦。</p><p>Git是真的好用，文档还没写完，明天起来接着写。</p><h2 id="3-31"><a href="#3-31" class="headerlink" title="3-31"></a>3-31</h2><p>有效复习时间大概3个小时？昨天睡太晚了，然后自己的状态也不好，感觉总是无法集中精神，复习没有什么章法。</p><p>数据结构好像没有想象中的那么难？可能我才看到线性表，后面的图什么的应该会非常难。</p><p>明天去找胡酱讨论408的具体复习事宜。</p><h2 id="4-1"><a href="#4-1" class="headerlink" title="4-1"></a>4-1</h2><p>愚人节摆烂</p><h2 id="4-2"><a href="#4-2" class="headerlink" title="4-2"></a>4-2</h2><p>又摆烂了。。。</p><p>上午复习进度挺好的，下午就彻底摆烂了，晚上更是在关心一些和自己无关的大事，浪费了好多复习时间，必须要改正，这样下去二战必输。</p><p>王道数据结构到97页了，还剩277页，预计到4月17日完成王道数据结构，也就是还有15天，考虑到难度梯度，现阶段每日进度应保证25页或以上，任务十分艰巨，而且数学还没有开始复习，压力不小啊。</p><p>明天继续把第三章和第四章写完，然后重点总结第三章的知识体系。</p><p>空谈无益，不要jz了，孙已经去西贡了，局面一定能稳住，这么多事情实际上与我没什么关系，要开始限制自己的消息源了。</p><h2 id="4-3"><a href="#4-3" class="headerlink" title="4-3"></a>4-3</h2><p>和胡酱聊了聊有关408的问题</p><h2 id="4-4"><a href="#4-4" class="headerlink" title="4-4"></a>4-4</h2><p>刚从乡下上来，一天啥都没做，属于是摆烂了。</p><h2 id="4-5"><a href="#4-5" class="headerlink" title="4-5"></a>4-5</h2><p>再次摆烂。。。不能这样下去了，明天早点起床早点开始干活</p><h2 id="4-6"><a href="#4-6" class="headerlink" title="4-6"></a>4-6</h2><p>半摆烂，把KMP给搞明白了，做到125页了，明天进展会快很多，毕竟KMP过了。</p><p>别的好像没啥，找到二战考研组织了，大伙一起努力。</p><p>下楼跑了1.25公里，可以继续提高运动量，明天跑个1.5？</p><h2 id="4-7"><a href="#4-7" class="headerlink" title="4-7"></a>4-7</h2><p>开始做课程设计去了，所以没写那么多408的题目，看看用一个星期能不能把课设给收拾了。</p><p>今天数据结构到131了，其实没看多少，毕设倒是把第一章和第二章的文字给整理了一下，明天找老师要一下人流量的数据开始计算了。</p><p>自行车挺好的，骑了差不多7公里，每天抽出一个小时运动运动还是很不错的。明天可以考虑骑10km</p><h2 id="4-8"><a href="#4-8" class="headerlink" title="4-8"></a>4-8</h2><p>骑行了12km，算是破了纪录，408没看，全部做毕设去了，任务量比想象的大一些，可能需要两个星期才能搞完。</p><h2 id="4-10"><a href="#4-10" class="headerlink" title="4-10"></a>4-10</h2><p>骑行14km，继续破纪录，408没看，继续专心做毕设，感觉一个星期做完也不是不可能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/03/24/shu-ju-jie-gou/"/>
      <url>/2022/03/24/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220320213629609.png" alt="image-20220320213629609" style="zoom:30%;" /></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220320213804112.png" alt="image-20220320213804112" style="zoom:30%;" /></p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321191934045.png" alt="image-20220321191934045" style="zoom:33%;" /></p><h3 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321110615100.png" alt="image-20220321110615100" style="zoom:40%;" /></p><h3 id="线性表的链式存储实现"><a href="#线性表的链式存储实现" class="headerlink" title="线性表的链式存储实现"></a>线性表的链式存储实现</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321131206579.png" alt="image-20220321131206579" style="zoom:40%;" /></p><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321175002890.png" alt="image-20220321175002890" style="zoom:40%;" /></p><h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321180249130.png" alt="image-20220321180249130" style="zoom:40%;" /></p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321183119741.png" alt="image-20220321183119741" style="zoom:40%;" /></p><h3 id="堆栈的抽象数据类型描述"><a href="#堆栈的抽象数据类型描述" class="headerlink" title="堆栈的抽象数据类型描述"></a>堆栈的抽象数据类型描述</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321183151848.png" alt="image-20220321183151848" style="zoom:40%;" /></p><h3 id="堆栈的顺序存储实现"><a href="#堆栈的顺序存储实现" class="headerlink" title="堆栈的顺序存储实现"></a>堆栈的顺序存储实现</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321183546175.png" alt="image-20220321183546175" style="zoom:40%;" /></p><h3 id="堆栈的链式存储实现"><a href="#堆栈的链式存储实现" class="headerlink" title="堆栈的链式存储实现"></a>堆栈的链式存储实现</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220321191656751.png" alt="image-20220321191656751" style="zoom:35%;" /></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列：具有一定操作约束的线性表。只能在一端插入，而在另一端删除。先进先出</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220322172933352.png" alt="image-20220322172933352" style="zoom:40%;" /></p><h3 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220322173337011.png" alt="image-20220322173337011" style="zoom:35%;" /></p><h3 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220322180505893.png" alt="image-20220322180505893" style="zoom:40%;" /></p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323110638150.png" alt="image-20220323110638150" style="zoom:33%;" /></p><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323111952566.png" alt="image-20220323111952566" style="zoom:33%;" /></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323113343247.png" alt="image-20220323113343247" style="zoom:40%;" /></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323113722227.png" alt="image-20220323113722227" style="zoom:33%;" /></p><h4 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323161242251.png" alt="image-20220323161242251" style="zoom:40%;" /></p><h4 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323162039050.png" alt="image-20220323162039050" style="zoom:40%;" /></p><p>ASL：平均成功查找次数</p><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323164625200.png" alt="image-20220323164625200" style="zoom:40%;" /></p><ol><li>子树是<strong>不相交</strong>的</li><li>除了根节点外，每个节点<strong>有且仅有</strong>一个父节点</li><li>一棵N个节点的树有<strong>N-1条边</strong></li></ol><h3 id="树的一些基本术语"><a href="#树的一些基本术语" class="headerlink" title="树的一些基本术语"></a>树的一些基本术语</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323164957638.png" alt="image-20220323164957638" style="zoom:40%;" /></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323165520525.png" alt="image-20220323165520525" style="zoom:40%;" /></p><h4 id="儿子兄弟表示法"><a href="#儿子兄弟表示法" class="headerlink" title="儿子兄弟表示法"></a>儿子兄弟表示法</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323170139347.png" alt="image-20220323170139347" style="zoom:40%;" /></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323170312098.png" alt="image-20220323170312098" style="zoom:40%;" /></p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323170500938.png" alt="image-20220323170500938" style="zoom:40%;" /></p><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323171528593.png" alt="image-20220323171528593" style="zoom:40%;" /></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323171759358.png" alt="image-20220323171759358"></p><h3 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323172724503.png" alt="image-20220323172724503" style="zoom:40%;" /></p><h3 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323173121717.png" alt="image-20220323173121717" style="zoom:40%;" /></p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323175351130.png" alt="image-20220323175351130" style="zoom:40%;" /></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323175504054.png" alt="image-20220323175504054" style="zoom:45%;" /></p><h4 id="链表存储"><a href="#链表存储" class="headerlink" title="链表存储"></a>链表存储</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323175620735.png" alt="image-20220323175620735" style="zoom:43%;" /></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323180224773.png" alt="image-20220323180224773" style="zoom:52%;" /></p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323180300966.png" alt="image-20220323180300966" style="zoom:33%;" /></p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323180342341.png" alt="image-20220323180342341" style="zoom:33%;" /></p><h4 id="性质小结"><a href="#性质小结" class="headerlink" title="性质小结"></a>性质小结</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323180446955.png" alt="image-20220323180446955" style="zoom:40%;" /></p><h4 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h4><h5 id="中序遍历非递归遍历算法"><a href="#中序遍历非递归遍历算法" class="headerlink" title="中序遍历非递归遍历算法"></a>中序遍历非递归遍历算法</h5><p>非递归算法实现的基本思路：使用<strong>堆栈</strong></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323210321894.png" alt="image-20220323210321894" style="zoom:40%;" /></p><p>先序遍历非递归就可以把print放在push后面，而后序遍历非递归就可以把<code>T-&gt;Left</code>和<code>T-&gt;Right</code>更换次序</p><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>二叉树遍历的核心问题：<strong>二维结构的线性化（一维化）</strong></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220323234503770.png" alt="image-20220323234503770" style="zoom:40%;" /></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序分为插入排序、交换排序、选择排序、归并排序、基数排序。</p><p>从插入排序写起，首先，插入排序分为直接插入排序、折半排序和希尔排序</p><p>直接插入排序的思路是取第一个数为基准，然后看第二个数与第一个数的大小关系，并对前两个数进行排列，以此类推。。。即将n+1号元素对其前面的n个元素的顺序子列进行从后往前、从大到小的比较，然后放置入对应的位置。空间复杂度为O(1)，时间复杂度为O(n2)，稳定</p><p>折半排序思路与直接插入排序类似，区别在于其在比较n+1号元素和前n个元素的子列时使用的是折半排序。空间复杂度时O(1)，间复杂度为O(n2)，稳定。</p><p>希尔排序相当于跳着走的插入排序，注意其增量会一直延伸到整个序列即可，时间复杂度为O(n1.3)，最坏情况下O(n2)，不稳定。</p><p>然后是交换排序，交换排序分为冒泡排序、快速排序。</p><p>冒泡排序是最简单的排序，一趟下来一定有一个元素抵达了它的最终位置。时间复杂度O(n2)，应该是稳定的把。</p><p>然后是重头戏快速排序，也就是快排。快排的思想是先确定一个元素在序列中的位置，然后再分别求其左右的一个元素对应的位置，以此类推。代码要背的，时间复杂度O(nlogn)，不稳定的排序方式，综合最优。</p><p>选择排序分为简单选择排序、堆排序。</p><p>简单选择排序就是在序列中找到最小值，然后将其交换到起点，以此类推，进行n-1次即可得出序列。时间复杂度为O(n2)，是稳定的排序方法。</p><p>堆排序，堆排序先将序列组成一个大根堆或者小根堆，然后从堆顶抽出一个元素，并将其与堆尾元素进行交换，然后令1到n-1元素重新进行成堆操作，以此类推，即可得出相应的序列。建立堆的时间复杂度为O(n)，每次调整的时间复杂度为O(h)，其中h为堆的高度，所以堆排序的时间复杂度为O(nlogn)，是一种不稳定的排序方法。</p><p>归并排序是指将序列先分开来，然后再两个两个，四个四个等的合并起来的排序方式。时间复杂度O(nlog2n)，稳定。</p><p>基数排序，很邪门，记住与初始状态无关，稳定即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>韩顺平java学习</title>
      <link href="/2022/02/25/han-lao-shi-java-jiao-cheng/"/>
      <url>/2022/02/25/han-lao-shi-java-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><div class="table-container"><table><thead><tr><th>进制</th><th>首位表示方式</th></tr></thead><tbody><tr><td>二进制</td><td>0B</td></tr><tr><td>十进制</td><td>无</td></tr><tr><td>八进制</td><td>0</td></tr><tr><td>十六进制</td><td>0X</td></tr></tbody></table></div><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="x进制转十进制"><a href="#x进制转十进制" class="headerlink" title="x进制转十进制"></a>x进制转十进制</h4><p>正常，没什么问题</p><h4 id="十进制转x进制"><a href="#十进制转x进制" class="headerlink" title="十进制转x进制"></a>十进制转x进制</h4><p>将该数不断除以x，直到商为0为止，然后将每一步得到的余数倒过来，就是对应的x进制</p><h4 id="二进制转八进制-十六进制"><a href="#二进制转八进制-十六进制" class="headerlink" title="二进制转八进制/十六进制"></a>二进制转八进制/十六进制</h4><p>从低位开始，将二进制三位/四位一组，转换成对应的八进制数即可。</p><h4 id="八进制-十六进制转二进制"><a href="#八进制-十六进制转二进制" class="headerlink" title="八进制/十六进制转二进制"></a>八进制/十六进制转二进制</h4><p>将八进制的每一位转成对应的一个3位二进制数即可，十六进制同理</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220124110005226.png" alt="image-20220124110005226" style="zoom:40%;" /></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul><li>按位与 &amp;：两位全为1，结果为1，否则为0；</li><li>按位或 |：两位只要有一个为1，即可为1，否则为0；</li><li>按位异或 ^：两位一个为0，一个为1，结果为1，否则为0；</li><li>按位取反 ~：0-&gt;1，1-&gt;0；</li><li>&gt;&gt;算数右移低位溢出，符号位不变，用符号位补溢出的高位；（溢出：扔掉）本质是除2的n次方</li><li>&lt;&lt;算数左移符号位不变，低位补0；本质是乘2的n次方</li><li>&gt;&gt;&gt;逻辑右移（无符号右移），低位溢出，高位补0；</li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h2 id="第8章-面向对象（初级）"><a href="#第8章-面向对象（初级）" class="headerlink" title="第8章 面向对象（初级）"></a>第8章 面向对象（初级）</h2><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220124195406956.png" alt="image-20220124195406956" style="zoom:30%;" /></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性=成员变量</p><h5 id="对象的引用和对象名："><a href="#对象的引用和对象名：" class="headerlink" title="对象的引用和对象名："></a>对象的引用和对象名：</h5><p>对象引用在栈里，对象在堆里</p><h3 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p1 <span class="token operator">=</span> p2<span class="token comment">//把p1赋给p2，或者说让p2指向p1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>先在堆中创建一个Person对象，再在方法区创建对象的常量和加载信息，并将其地址返回给堆，基本数据类型则直接存放于堆中，而后将堆中的对象地址返回给栈中的p2,p2指向该地址。p1在栈中指向p2复制得到的地址。</p><p>Java内存结构分析</p><ol><li>栈：一般存放基本数据类型（局部变量）；</li><li>堆：存放对象（Person person，数组等）；</li><li>方法区：常量池（常量，比如字符串），类加载信息</li></ol><p>Java创建对象的流程简单分析</p><ol><li>先加载Person类信息（属性和方法信息，只加载一次）；</li><li>在堆中分配空间，进行默认初始化；</li><li>将地址赋给p，p指向对象；</li><li>进行指定初始化，比如：<code>p.name = &quot;jack&quot;;</code></li></ol><h3 id="成员方法（方法）"><a href="#成员方法（方法）" class="headerlink" title="成员方法（方法）"></a>成员方法（方法）</h3><p>方法调用机制</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220126195934038.png" alt="image-20220126195934038" style="zoom: 33%;" /></p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li><li>方法的局部变量时独立的，不会相互影响，比如n变量</li><li>如果方法中使用的是引用类型变量（比如数组、对象），就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，就会死龟</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就结果返回给谁，同时当方法执行完毕或者返回时，该方法就执行完毕</li></ol><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><h4 id="注意事项和使用细节"><a href="#注意事项和使用细节" class="headerlink" title="注意事项和使用细节"></a>注意事项和使用细节</h4><ol><li>可变参数的实参可以为0个或者任意多个</li><li>可变参数的实参可以为数组</li><li>可变参数的本质就是数组</li><li>可变参数可以和普通参数类型的参数一起放在形参列表，但必须保证可变参数在最后</li><li>一个形参列表中只能出现一个可变参数</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>全局变量和局部变量</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220128105339594.png" alt="image-20220128105339594" style="zoom:40%;" /></p><p>全局变量可以用修饰符，局部变量不可以</p><h3 id="构造器（构造方法）"><a href="#构造器（构造方法）" class="headerlink" title="构造器（构造方法）"></a>构造器（构造方法）</h3><p>一旦定义了自己的构造器，那么无参构造器（默认构造器）就被覆盖，就不能再使用无参构造器，除非自己重新定义一个无参构造器</p><p>构造器并不创建对象，而是对对象进行初始化</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this指当前对象自己</p><p>简单地说，哪个对象调用，this就代表了哪个对象</p><h4 id="this的注意事项和使用细节"><a href="#this的注意事项和使用细节" class="headerlink" title="this的注意事项和使用细节"></a>this的注意事项和使用细节</h4><ol><li>this关键字可以用来访问本类的属性、方法、构造器</li><li>this用于区分当前类的属性和局部变量</li><li>访问成员方法的语法：<code>this.方法名(参数列表)</code></li><li>访问构造器的语法：<code>this(参数列表)</code>。<strong>注意只能在构造器中使用</strong>（即只能在构造器中访问另外一个构造器，必须放在第一条语句）</li><li>this不能在类定义的外部使用，只能在类定义的方法中使用</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//构造器语法:this(参数列表)；必须放置于第一条语句</span><span class="token keyword">public</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只能在构造器中使用这种语法，其他成员方法不得使用</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">T</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>this.name</code>访问的一定是类的属性，而<code>name</code>则有可能访问的是成员方法的局部变量</p><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><ol><li><p>静态初始化</p><p>在定义数组的同时对数组元素进行初始化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BankAccount</span><span class="token punctuation">[</span><span class="token punctuation">]</span> accounts <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token keyword">new</span> <span class="token class-name">BankAccount</span><span class="token punctuation">(</span>“<span class="token class-name">Zhang</span>"<span class="token punctuation">,</span> <span class="token number">100.00</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">BankAccount</span><span class="token punctuation">(</span>“<span class="token class-name">Li</span>"<span class="token punctuation">,</span> <span class="token number">2380.00</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>动态初始化</p><ul><li><p>使用运算符new为数组分配空间 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">type<span class="token punctuation">[</span> <span class="token punctuation">]</span> arrayName<span class="token operator">=</span><span class="token keyword">new</span> type<span class="token punctuation">[</span>arraySize<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>只是对象数组本身分配空间，并<strong>没有对数组元素进行初始化</strong>，即<strong>数组元素均为空</strong>，因此下列程序会报错</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        people<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"yyh"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="第9章-面向对象（中级）"><a href="#第9章-面向对象（中级）" class="headerlink" title="第9章 面向对象（中级）"></a>第9章 面向对象（中级）</h2><h3 id="IDEA编译器"><a href="#IDEA编译器" class="headerlink" title="IDEA编译器"></a>IDEA编译器</h3><h4 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h4><ol><li>删除当前行<code>ctrl+d</code></li><li>复制当前行<code>ctrl+alt+向下光标</code></li><li>补全代码<code>alt+/</code></li><li>添加注释或者取消注释<code>ctrl+/</code></li><li>导入该行需要的类<code>alt+enter</code></li><li>快速格式化代码<code>ctrl+alt+L</code></li><li>快速运行程序<code>alt+R</code></li><li>生成构造方法<code>alt+insert</code></li><li>查看一个类的层级关系<code>ctrl+H</code></li><li>定位类的方法，查看某方法的源码<code>ctrl+B</code></li><li>自动分配变量名<code>.var</code></li></ol><h4 id="IDEA模板"><a href="#IDEA模板" class="headerlink" title="IDEA模板"></a>IDEA模板</h4><p><code>settings-&gt;Editor-&gt;Live Templates</code>里面都有</p><h4 id="IDEA小技巧"><a href="#IDEA小技巧" class="headerlink" title="IDEA小技巧"></a>IDEA小技巧</h4><p>点左下角的Structure可以看到一个对象的方法</p><p>在IDEA中动态传参数：Edit Configurations -&gt; Program arguments</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>作用</p><ol><li>区分相同名字的类</li><li>当类很多时，可以很好地管理类</li><li>控制访问范围</li></ol><p>基本语法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">//package打包，后接包名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="包的本质"><a href="#包的本质" class="headerlink" title="包的本质"></a>包的本质</h4><p>创建不同的文件夹来保存类文件</p><h4 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h4><p>只能包含数字、字母、下划线、小圆点。但是不能用数字开头，不能是关键字或保留字</p><p>一般是小写字母+小圆点，一般是<code>com.公司名.项目名.业务名</code>，例如<code>com.sina.crm.user</code></p><h4 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h4><p><code>java.lang.*</code>默认引入</p><p><code>java.util.*</code>系统提供的工具包</p><p><code>java.net.*</code>网络包，网络开发</p><p><code>java.awt.*</code>java界面开发，GUI</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>package声明当前类所在的包，需要放在类的最上面，一个类最多只有一句package</p><p>import指令要求在package下面，可以有多句且没有顺序要求</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220129223654194.png" alt="image-20220129223654194" style="zoom:40%;" /></p><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><div class="table-container"><table><thead><tr><th>访问级别</th><th>访问修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>公开</td><td>public</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>受保护</td><td>protected</td><td>✓</td><td>✓</td><td>✓</td><td></td></tr><tr><td>默认</td><td>没有修饰符</td><td>✓</td><td>✓</td><td></td><td></td></tr><tr><td>私有</td><td>private</td><td>✓</td><td></td><td></td></tr></tbody></table></div><h3 id="封装（encapsulation）"><a href="#封装（encapsulation）" class="headerlink" title="封装（encapsulation）"></a>封装（encapsulation）</h3><p>将抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作</p><h4 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h4><ol><li>隐藏实现的细节</li><li>对数据进行验证，保证安全合理</li></ol><h4 id="封装的实现步骤（三部曲）"><a href="#封装的实现步骤（三部曲）" class="headerlink" title="封装的实现步骤（三部曲）"></a>封装的实现步骤（三部曲）</h4><ol><li>将属性进行私有化private【外部不能直接修改属性】</li><li>提供一个公共的(public)set方法，用于对属性判断并赋值</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setXxx</span><span class="token punctuation">(</span>类型 参数名<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//加入数据验证的业务逻辑</span>    属性 <span class="token operator">=</span> 参数名；<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 可以使用快捷键处理</p><ol><li>提供一个公共的(public)get方法，用于获取属性的值</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">XX</span> <span class="token function">getXxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//权限判断，Xxx某个属性</span>    <span class="token keyword">return</span> xx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="封装与构造器"><a href="#封装与构造器" class="headerlink" title="封装与构造器"></a>封装与构造器</h4><p>将set方法写在构造器中，仍然可以起到防护的机制</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//this.age = age;</span>    <span class="token comment">//this.name = name; 这样不好</span>    <span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这样更好</span>    <span class="token function">setAge</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><p>用于解决代码复用问题。多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类（超类），在父类中定义这些相同的属性和方法，所有的子类不需要再重新定义这些属性和方法，只需要通过extends来声明继承父类即可。</p><p><strong>继承设计的基本思想</strong>：父类构造器完成父类属性初始化，子类构造器完成子类属性初始化</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220130165109518.png" alt="image-20220130165109518" style="zoom:45%;" /></p><h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> 子类 <span class="token keyword">extends</span> 父类<span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>子类自动拥有父类定义的属性和方法</li><li>父类又叫超类、基类</li><li>子类又叫派生类</li></ol><h4 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h4><ol><li><p>子类继承了所有的属性和方法，<strong>非私有的属性和方法可以直接访问在子类直接访问</strong>，<strong>但是私有属性和方法不能在子类直接访问</strong>，要通过公共的方法来访问</p></li><li><p>子类必须调用父类的构造器，完成父类的初始化。子类里面默认调用了父类的无参构造器<code>super()</code>。</p></li><li><p>当创造子类对象时，不管使用子类的哪个构造器，<strong>默认情况下总会去调用父类的无参构造器</strong>，如果父类没有提供无参构造器，则必须在子类的构造器中用super去<strong>指定使用父类的哪个构造器完成对父类的初始化工作</strong>，否则编译不会通过。</p></li><li><p>如果希望指定去调用父类的某个构造器，则显示的调用一下。</p><p>如果不是默认的无参构造器，那么需要显示调用父类的该构造器<code>super(对应实参)</code></p></li><li><p><code>super</code>在使用时，必须放在构造器第一行</p></li><li><p><code>super()</code>和<code>this()</code>都只能放在构造器第一行，因此这两个方法不能共存于同一个构造器，二者不能同时存在。</p></li><li><p>java所有类都是Object类的子类，Object是所有类的基类（<code>ctrl+H</code>可以看到类的继承层次）</p></li><li><p>父类构造器的调用不限于直接父类，将一直追溯直到Object类（顶级父类）。调用了就会从祖宗到子类一路下来，全部调。</p></li><li><p>子类最多只能继承一个父类（直接继承），即java是单继承机制。若想让A继承B和C，则可以让B继承C后，再让A继承B。</p></li><li><p>不能滥用继承，子类和父类必须满足<strong>is-a</strong>的逻辑关系</p></li></ol><h4 id="继承的本质分析（重要）"><a href="#继承的本质分析（重要）" class="headerlink" title="继承的本质分析（重要）"></a>继承的本质分析（重要）</h4><p>当子类对象创建好后，建立查找的关系</p><p>示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExtendsTheory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Son</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">GrandPa</span> <span class="token punctuation">&#123;</span><span class="token comment">//爷类</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"大头爷爷"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> hobby <span class="token operator">=</span> <span class="token string">"旅游"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">GrandPa</span> <span class="token punctuation">&#123;</span><span class="token comment">//父类</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"大头爸爸"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span><span class="token comment">//子类</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"大头儿子"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内存布局</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220130214915549.png" alt="image-20220130214915549" style="zoom:40%;" /></p><ol><li>首先看子类是否有该属性</li><li>如果子类有这个属性，且可以访问，则返回信息</li><li>如果子类没有这个属性，就看父类有没有这个属性（如果父类有该属性。且可以访问，就返回信息。。。。）</li><li>如果父类没有，就按照（3）的规则，继续找上级父类，直到Object。。。</li></ol><p>private的属性也存在于堆中，但是不能直接访问，使用方法间接访问即可。如果上级有public的，直接访问的话其会访问第一个public。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExtendsTheory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>    <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a的无参构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a的有参构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>    <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//由于下面有this，此处原本隐藏的super()被撤销</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token string">"abs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b的无参构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//此处隐藏了一个super()</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b的有参构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的是</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a的无参构造器b的有参构造器b的无参构造器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先从进入B无参构造器的this中，<strong>注意此处由于B的无参构造器有<code>this</code>，因此此处的默认的<code>super()</code>也消失了,所以他直接进入了<code>this</code>而没有处理<code>super()</code></strong>。然后进入B的有参构造器，此处有一个默认的<code>super()</code>，所以进入A的无参构造器，而后输出B的有参构造器中的内容。最后回到B的无参构造器，输出其内容。记住，<strong>所有构造器在没有this存在的时候都有一个默认的super()</strong></p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super代表父类的引用，用于访问父类的属性、方法、构造器</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ol><li><p>访问父类的属性，但不能访问父类的private属性</p><p><code>super.属性名</code></p></li><li><p>访问父类的方法，但不能访问父类的private方法</p><p><code>super.方法名(参数列表)</code></p></li><li><p>访问父类的构造器（这点前面用过）：</p><p><code>super(参数列表);</code>只能用在构造器的第一句，只能出现一句。</p></li></ol><h4 id="super给编程带来的便利-细节"><a href="#super给编程带来的便利-细节" class="headerlink" title="super给编程带来的便利/细节"></a>super给编程带来的便利/细节</h4><ol><li>调用父类构造器的好处（分工明确）</li><li><p>当子类有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。若没有重名，使用super、this、直接访问都是一样的结果。直接访问的顺序：先找本类，如果有，则调用，如果没有，则找父类，直到Object。super顺序：直接查找父类，跳过本类，其他逻辑一致。</p></li><li><p>super的访问不限于直接父类，如果爷爷类和本类都有同名的成员，也可以使用super去访问爷爷类的成员；如多个基类都有同名成员，使用super方法遵循就近原则。</p></li></ol><h4 id="super和this的比较"><a href="#super和this的比较" class="headerlink" title="super和this的比较"></a>super和this的比较</h4><div class="table-container"><table><thead><tr><th>No.</th><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>1</td><td>访问成员</td><td>访问本类的成员，如果本类没有就去找父类</td><td>直接访问父类中的成员，跳过本类</td></tr><tr><td>2</td><td>调用构造器</td><td>调用本类构造器，必须放在构造器首行</td><td>调用父类构造器，必须放在子类构造器首行</td></tr><tr><td>3</td><td>特殊</td><td>表示当前对象</td><td>子类中访问父类对象</td></tr></tbody></table></div><h3 id="方法重写-覆盖（override）"><a href="#方法重写-覆盖（override）" class="headerlink" title="方法重写/覆盖（override）"></a>方法重写/覆盖（override）</h3><p>子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们说这个子类的方法覆盖了父类的方法</p><h4 id="注意事项和使用细节-1"><a href="#注意事项和使用细节-1" class="headerlink" title="注意事项和使用细节"></a>注意事项和使用细节</h4><ol><li>子类的方法的参数、方法名称，要和父类方法的参数、方法名称完全一致</li><li>子类的返回类型和父类方法返回类型一样，或者是父类返回类型的子类。例如父类返回Object，子类返回String</li><li>子类方法不能缩小父类方法的权限</li></ol><h3 id="多态（polymorphic）"><a href="#多态（polymorphic）" class="headerlink" title="多态（polymorphic）"></a>多态（polymorphic）</h3><p>问题：代码复用性不高，不利于代码维护</p><p>多态：方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p><p>Java有两种引用类型，分别是编译时类型和运行时类型。编译型类型在变量声明时决定，运行时类型取决于变量具体指向的类型，如果两种类型不一致，就会出现多态。</p><p>规则：对象调用编译时类型的属性和运行时类型的方法。</p><h4 id="具体体现"><a href="#具体体现" class="headerlink" title="具体体现"></a>具体体现</h4><ol><li><p>方法的多态：重载和重写体现多态</p></li><li><p>对象的多态（<strong>核心、困难、重点</strong>）</p><ul><li><p>一个对象的编译类型和运行类型可以不一致</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Animal</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//【animal编译类型是Animal，运行类型是Dog】</span>animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//【animal的运行类型变成了Cat，编译类型仍然是Animal】</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>编译类型在定义对象时就确定了，<strong>不能改变</strong>。（编译器可以认为是编译器看到的类型）（直接把编译类型看成指针类型就好了）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//编译类型Animal确定了，不能改变</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>运行类型是<strong>可以变化</strong>的。（运行类型则是运行时真正起作用的类型）。可以通过<code>getClass()</code>来查看运行类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//运行类型Dog可以变成Cat</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>编译类型</strong>看定义时 <code>=</code> 号的左边，<strong>运行类型</strong>看 <code>=</code> 号的右边。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//使用多态可以统一管理主人喂食的问题</span><span class="token comment">//animal编译类型是Animal，可以指向（接收）Animal子类的对象</span><span class="token comment">//food编译类型是Food，可以指向（接收）Food子类的对象</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">feed</span><span class="token punctuation">(</span><span class="token class-name">Animal</span> animal<span class="token punctuation">,</span><span class="token class-name">Food</span> food<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"主人给"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"给"</span> <span class="token operator">+</span> animal<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"吃"</span> <span class="token operator">+</span> food<span class="token punctuation">.</span>getName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="多态注意事项和细节讨论"><a href="#多态注意事项和细节讨论" class="headerlink" title="多态注意事项和细节讨论"></a>多态注意事项和细节讨论</h4><ol><li><p>前提：两个对象（类）存在继承关系</p></li><li><p>多态的向上转型</p><ul><li><p>本质：父类的引用指向了子类的对象（继承图里面父类在上面，子类在下面，所以叫向上转型）</p></li><li><p>语法：<code>父类类型 引用名 = new 子类类型();</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Animal</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>特点：</p><ul><li><p><strong>编译类型</strong>看左边，<strong>运行类型</strong>看右边。</p></li><li><p>可以调用父类中的所有成员（遵循访问权限（也就是public，private这种））</p></li><li><p>不能调用子类中的特有成员（因为在编译阶段，能调用哪些成员是由编译类型决定）</p></li><li><p>最终运行效果看子类的具体表现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">animal<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//先去cat中找eat，再去animal找。。。与方法的调用规则一致</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul></li><li><p>多态的向下转型</p><ul><li><p>语法：<code>子类类型 应用名 = （子类类型）父类引用;</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Cat</span> cat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Cat</span><span class="token punctuation">)</span> animal<span class="token punctuation">;</span><span class="token comment">//cat的编译类型是Cat，运行类型是Cat</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>只能强转父类的<strong>引用</strong>，不能强转父类的<strong>对象</strong>（小明这个人就是这个人，他可以改名，但是他不能不是他自己）</p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象</p></li><li><p>当向下转型后，可以调用子类类型中所有的成员</p></li></ul><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230913210624732.png" alt="向上转型和向下转型的示意图" style="zoom:80%;" /></p><p>需要注意的是：图中指向方向是从 <strong>对象</strong> 指向其对应的 <strong>引用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> o <span class="token operator">=</span> string<span class="token punctuation">;</span> <span class="token comment">//此处为一个向上转型。解释为对一个string对象赋予Object，父类的引用指向了子类的对象。</span><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span><span class="token comment">//此处为一个向下转型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>属性没有重写之说，属性的值看<strong>编译类型</strong>，编译器通过编译类型去寻找属性（成员变量）。而方法则是通过<strong>运行类型</strong>，然后根据相应的<strong>继承顺序</strong>来访问（前面写过这个顺序）。</p></li><li><p><code>instanceOf</code> 比较操作符，用于判断对象的<strong>运行类型</strong>是否为XX类型或XX类型的子类型</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Sub</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//20</span>        s<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//20</span>        <span class="token class-name">Base</span> b <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b <span class="token operator">==</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里要注意了，属性的值看编译类型，此处b的编译类型是Base，因此count=10</span>        b<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//与上面不同，方法从子类开始找起，看的是运行类型，所以其取20</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/Bixlku/JavaStudyCode/tree/main/PolyMorphism">多态示例代码</a></p><h4 id="Java的动态绑定机制（非常非常重要）"><a href="#Java的动态绑定机制（非常非常重要）" class="headerlink" title="Java的动态绑定机制（非常非常重要）"></a>Java的动态绑定机制（非常非常重要）</h4><ol><li>当调用对象方法的时候，该方法会和该对象的内存地址（<strong>运行类型</strong>）绑定</li><li>当调用对象属性时，<strong>没有动态绑定机制</strong>，哪里声明，哪里使用</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicBinding</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//40->30</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">sum1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//30->20</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sum1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment">// public int sum() &#123;</span>    <span class="token comment">//     return i + 20;</span>    <span class="token comment">// &#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// public int sum1() &#123;</span>    <span class="token comment">//     return i + 10;</span>    <span class="token comment">// &#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/Bixlku/JavaStudyCode/tree/main/DynamicBinding">Java动态绑定机制示例代码</a></p><h4 id="多态应用"><a href="#多态应用" class="headerlink" title="多态应用"></a>多态应用</h4><ol><li><p>多态数组</p><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p></li><li><p>多态参数</p><p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p></li></ol><h3 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h3><h4 id="equals和"><a href="#equals和" class="headerlink" title="equals和=="></a>equals和==</h4><p>==：</p><ol><li>如果判断基本类型，则判断的是值是否相等</li><li>如果判断引用类型，则判断地址是否相等，即判定是不是同一个对象</li><li>如果不是同一个类型，且其无继承关系，会报错</li></ol><p>equals：</p><p>只能判断引用类型，默认判断的是地址是否相相等，子类中往往重写该方法，用于判断内容是否相等</p><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><ol><li>提高具有哈希结构的容器的效率</li><li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</li><li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li><li>哈希值主要是根据地址号来的，不能将哈希值等价于地址</li><li>后面在集合中，hashCode如果需要的话，也会重写</li></ol><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><ol><li><p>默认返回：全类名+@+哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性信息</p></li><li><p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式</p></li><li><p>输出一个对象时，toString方法会被默认调用</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>会默认调用a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><ol><li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法。finalize本身是空的，可以重写该方法来实现自己的业务逻辑。</li><li>什么时候被回收：当某个对象没有被任何引用时，则JVM就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象。在销毁该对象前，会先调用finalize方法</li><li>垃圾回收机制的调用，是由系统来决定（即有自己的GC算法），也可以通过<code>System.gc()</code>主动触发垃圾回收机制</li></ol><h3 id="零钱通"><a href="#零钱通" class="headerlink" title="零钱通"></a>零钱通</h3><p><a href="https://github.com/Bixlku/JavaStudyCode/tree/main/SmallChange">零钱通示例代码</a></p><h3 id="房屋出租"><a href="#房屋出租" class="headerlink" title="房屋出租"></a>房屋出租</h3><p><a href="https://github.com/Bixlku/JavaStudyCode/tree/main/HouseRent">房屋出租示例代码</a></p><h2 id="第10章-面向对象（高级）"><a href="#第10章-面向对象（高级）" class="headerlink" title="第10章 面向对象（高级）"></a>第10章 面向对象（高级）</h2><h3 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h3><ol><li>类变量由同一个类所有对象共享</li><li>类变量在类加载的时候就生成了</li></ol><h4 id="类变量使用细节"><a href="#类变量使用细节" class="headerlink" title="类变量使用细节"></a>类变量使用细节</h4><ol><li><p>什么时候使用类变量</p><p>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</p></li><li><p>加上<code>static</code>称为类变量或静态变量，否则成为实例变量/普通变量/非静态变量</p></li><li><p>类变量可以通过 <code>类名.类变量名</code> 访问或者 <code>对象名.类变量名</code> 来直接访问，推荐使用 <code>类名.类变量名</code> 访问</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span><span class="token punctuation">.</span>id<span class="token comment">//更好</span><span class="token class-name">Jack</span><span class="token punctuation">.</span>id<span class="token comment">//不推荐</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><h4 id="类方法基本介绍"><a href="#类方法基本介绍" class="headerlink" title="类方法基本介绍"></a>类方法基本介绍</h4><p>类方法也叫静态方法，形式如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">访问修饰符 <span class="token keyword">static</span> 数据返回类型 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> 【推荐】<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用方式：</p><pre class="line-numbers language-none"><code class="language-none">类名.类方法名&#x2F;对象名.类方法名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="类方法经典的使用场景"><a href="#类方法经典的使用场景" class="headerlink" title="类方法经典的使用场景"></a>类方法经典的使用场景</h4><p>当方法中<strong>不涉及到任何和对象相关的成员</strong>，则可以将方法设计成静态方法，提高开发效率。（例如工具类(<code>utils类</code>)、Math类、Arrays类。。。。。）即把方法当作工具使用，无需创建对象。</p><h4 id="类方法注意事项和细节讨论"><a href="#类方法注意事项和细节讨论" class="headerlink" title="类方法注意事项和细节讨论"></a>类方法注意事项和细节讨论</h4><ol><li><p>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：</p><p>类方法无<code>this</code>参数，普通方法隐含<code>this</code>参数</p></li><li><p>类方法可以通过类名调用，也可以通过对象名调用；普通方法和对象有关，需要通过对象名调用</p></li><li><p>类方法不允许使用和<strong>对象</strong>有关的关键字（fff！！），比如<code>this</code>和<code>super</code>。普通方法（成员方法）则可以</p></li><li><p>类方法（静态方法）<strong>只能访问</strong> 静态变量 或 静态方法</p></li><li><p>普通成员方法，既可以非静态成员，也可以访问静态成员</p></li><li><p>静态方法只会运行一次</p></li></ol><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><ol><li>main方法由虚拟机调用</li><li>java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public（虚拟机和main不在同一个类）</li><li>java虚拟机在调用main()方法时不必创建对象，所以该方法必须是static</li><li>该方法接收String()类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li><li><code>java执行的程序 参数1 参数2 参数3</code> 命令行运行</li><li>main方法是静态方法，可以直接调用main方法所在的类的静态方法，但是不能访问该类中的非静态成员（必须在创建一个实例后才能访问）</li></ol><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>代码块又称为代码块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。但其和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。</p><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">(</span>optional<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>code<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>修饰符（static）可选，分为静态代码块和普通代码块（非静态代码块）</li><li>分号（；）可以省略</li></ul><h4 id="代码块的好处"><a href="#代码块的好处" class="headerlink" title="代码块的好处"></a>代码块的好处</h4><ul><li>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li><li>场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性。这样不管用哪个构造器创建任意一个对象，都会调用代码块的内容</li></ul><h4 id="代码块使用注意事项和细节讨论"><a href="#代码块使用注意事项和细节讨论" class="headerlink" title="代码块使用注意事项和细节讨论"></a>代码块使用注意事项和细节讨论</h4><ol><li><p>static代码块也叫做静态代码块，作用是对类进行初始化，而且它随着类的<strong>加载</strong>而执行，并且只会<strong>执行一次</strong>。</p><p>如果是普通代码块，每<strong>创建</strong>一次实例（new）就执行一次。</p><p>如果只是使用类调用静态成员，普通代码块并不会被执行（可以理解为构造器未被调用）。</p></li><li><p><strong>类什么时候被加载</strong>【重要！必备】【<strong>加载</strong>不等于<strong>创建</strong>，类加载早于对象创建，类加载不一定创建了对象】</p><ul><li><p>创建对象实例时（new）</p></li><li><p>创建子类对象实例，父类也会被加载</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CodeBlock</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//类被加载的情况举例</span>        <span class="token comment">//1.创建对象(new)</span>        <span class="token class-name">AA</span> aa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">AA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.创建子类对象那实例，父类也会被加载，而且父类先被加载，子类后被加载</span>        <span class="token class-name">BB</span> bb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">BB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.使用类的静态成员时(静态方法、静态成员)</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span>n1<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> AA<span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AA的静态代码块1被执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> BB <span class="token keyword">extends</span> AA<span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BB的静态代码块1被执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cat的静态代码块1被执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用类的静态成员时（静态属性，静态方法）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CodeBlock</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//静态代码块在类加载时执行，而且只会被执行一次</span>        <span class="token comment">//下列语句只会输出一次"DD的静态方法被代码块1执行"</span>        <span class="token comment">//普通代码块在每创建一次类就会执行一次</span>        <span class="token comment">//下列两行会输出两次"DD普通代码块被代码块1执行"</span>        <span class="token class-name">DD</span> dd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">DD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">DD</span> dd1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">DD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//如果只是使用类调用静态成员，普通代码块并不会被执行</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>DD<span class="token punctuation">.</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">///输出888，静态代码块会执行，普通代码块不会执行</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> DD<span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">888</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DD的静态方法被代码块1执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DD普通代码块被代码块1执行"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>创建一个对象时，在一个类调用顺序是【重点，难点】：</p><ol><li><p>调用静态代码块和静态属性初始化（类加载早于对象创建）</p><p>（注意：静态代码和静态属性初始化调用的优先级一样，如果有多个静态代码和多个静态变量初始化，则按他们定义的顺序调用）</p></li><li><p>调用普通代码块和普通属性的初始化</p><p>（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）</p></li><li><p>调用构造方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CodeBlock2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(1)getN1被调用 (2)A的静态代码块 (3)getN2被调用 (4)A的普通代码块 (5)A无参构造器被调用</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token function">getN1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token function">getN2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A的普通代码块01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(4)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A静态代码块01"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(2)</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getN1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getN1被调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(1)</span>        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getN2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getN2被调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(3)</span>        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A无参构造器被调用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(5)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构造方法（构造器）的最前面其实隐含了<strong>super()</strong>和 <strong>调用普通代码块</strong> ，静态相关的代码块，属性初始化，在类加载时就已经执行完毕。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//这里有隐藏的执行要求</span>        <span class="token comment">//1)super();</span>        <span class="token comment">//2)调用本类普通代码块</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建子类时（有继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</p><ol><li>父类的静态代码块和静态属性初始化（优先级一致，按定义顺序执行）</li><li>子类的静态代码块和静态属性初始化（优先级一致，按定义顺序执行）</li><li>父类的普通代码块和普通属性初始化（优先级一致，按定义顺序执行）</li><li>父类构造方法</li><li>子类的普通代码块和普通属性初始化（优先级一致，按定义顺序执行）</li><li>子类构造方法</li></ol><p><a href="https://github.com/Bixlku/JavaStudyCode/blob/main/CodeBlock/CodeBlockExam.java">代码块综合测试源代码</a></p></li><li><p>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</p></li></ol></li></ol><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><h4 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h4><ol><li>静态方法和属性的经典应用</li><li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索</li></ol><h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>单例（单个实例）</p><ol><li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</li><li><p>单例模式有两种方式：1） 饿汉式    2）懒汉式</p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4></li></ol><p>即使未使用对象，对象也可能被创建了。饿汉式在加载时就创建了对象，有可能并不使用而造成资源浪费。</p><ol><li><p>构造器私有化 =》防止直接new</p></li><li><p>类的内部创建对象</p></li><li><p>向外暴露一个静态的公共方法。 <code>getInstance</code>（instance：实例）</p></li><li><p>代码实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SingleTon01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">SingleTon01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//为了能在静态方法中，返回instance对象，因此将其修饰为static</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SingleTon01</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleTon01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingleTon01</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>只有使用了getInstance时，才会返回对象，后面再调用时，会返回上次创建的对象，从而保证单例。即使加载类，也不会创建对象</p><ol><li>构造器私有化</li><li>定义一个static静态属性对象</li><li>提供一个public的static方法，返回一个实例</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SingleTon02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">SingleTon01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SingleTon02</span> instance<span class="token punctuation">;</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingleTon02</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//如果没创建对象，就进行创建</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleTon02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="饿汉式VS懒汉式"><a href="#饿汉式VS懒汉式" class="headerlink" title="饿汉式VS懒汉式"></a>饿汉式VS懒汉式</h4><ol><li>二者最主要的区别在于创建对象的<strong>时机</strong>不同 ：饿汉式在类加载时就创建了对象实例，而懒汉式是在使用时才创建</li><li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li><li>饿汉式有浪费资源的可能。</li><li>Java SE中，java.lang.Runtime就是经典单例模式</li></ol><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>final可以修饰 类、属性、方法和局部变量</p><p>在某些情况下，程序员可能有以下需求，就会用到final：</p><ul><li>但不希望父类被继承时，可以用final修饰</li><li>但不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰【访问修饰符 final 返回类型 方法名】</li><li>但不希望类的某个属性的值被修改，可以用final修饰</li><li>但不希望某个局部变量被修改，可以用final修饰</li></ul><h4 id="final使用注意事项和细节讨论"><a href="#final使用注意事项和细节讨论" class="headerlink" title="final使用注意事项和细节讨论"></a>final使用注意事项和细节讨论</h4><ol><li><p>final修饰的属性又叫常量，一般用<code>XX_XX_XX</code>来命名</p></li><li><p>final修饰的属性在<strong>定义</strong>时，必须赋初值，并且以后不能再修改，赋初值可以在如下位置之一：</p><ol><li>定义时：如<code>public final double TAX_RATE  = 0.08;</code></li><li>在构造器中</li><li>在代码块中</li></ol></li><li><p>如果final修饰的属性是<strong>静态</strong>的，则赋初值的位置只能是</p><ol><li><p>定义时</p></li><li><p>在静态代码块</p><p>不能在构造器中赋值</p></li></ol></li><li><p>final类不能继承，但是可以实例化对象</p></li><li><p>如果类不是final类，但是含有final方法，则虽然该方法不能重写，但是可以被继承</p></li><li><p>一般来说，如果一个类已经是final类了，那么其方法就没必要修饰成final了（继承都不行怎么可能重写）</p></li><li><p>final不能修饰构造方法</p></li><li><p>final和static往往搭配使用，效率更高，<strong>不会导致类加载</strong>，底层编译器做了优化处理。</p></li><li><p>包装类（Integer，Double，Float，Boolean等）都是final，String也是final类</p></li></ol><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。</p><p>所谓抽象方法就是没有实现的方法，所谓没有实现就是指没有方法体，当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类。一般来说，抽象类会被继承，由其子类来实现抽象方法。</p><h4 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h4><ol><li><p>用abstract关键字来修饰一个类时，这个类就叫抽象类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">访问修饰符 <span class="token keyword">abstract</span> 类名<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>用abstract关键字来修饰一个方法时，这个方法就是抽象方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">访问修饰符 <span class="token keyword">abstract</span> 返回类型 方法名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//没有方法体</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类你</p></li></ol><h4 id="抽象类的注意事项和细节讨论"><a href="#抽象类的注意事项和细节讨论" class="headerlink" title="抽象类的注意事项和细节讨论"></a>抽象类的注意事项和细节讨论</h4><ol><li><p>抽象类不能被实例化</p></li><li><p>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有抽象方法</p></li><li><p>一旦包含了abstract方法，则这个类必须声明为abstract</p></li><li><p>abstract只能修饰 类 和 方法 ，不能修饰属性和其他的</p></li><li><p>抽象类可以有任意成员【抽象类还是类】，比如：非抽象方法、构造器、静态属性等</p></li><li><p>抽象方法不能有主体，即下面这种写法是错误的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//不能写大括号</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它本身也声明为抽象类</p></li><li><p>抽象类不能使用private、final、static，因为这些关键字和重写相违背</p></li></ol><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。语法（implements：实施/实现)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> 接口名<span class="token punctuation">&#123;</span>    <span class="token comment">//属性</span>    <span class="token comment">//方法（1.抽象方法 2.默认实现方法 3.静态方法）</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> 类名 <span class="token keyword">implements</span> 接口 <span class="token punctuation">&#123;</span>    自己属性<span class="token punctuation">;</span>    自己方法<span class="token punctuation">;</span>    必须实现的接口的全部抽象方法<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小结：</p><ol><li>在JDK7.0之前 接口里的所有方法都没有方法体，即都是抽象方法</li><li>JDK8.0之后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</li><li>在接口中， 抽象方法可以省略abstract关键字</li><li>默认方法需要在方法前加default</li></ol><h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol><li><p>接口不能被实例化</p></li><li><p>接口中所有的方法都是<strong>public</strong>方法，接口中抽象方法，可以不用abstract修饰</p></li><li><p>一个普通类实现接口，就必须将该接口的所有方法都实现（IDEA中可以用<code>alt</code>+<code>enter</code>解决）</p></li><li><p><strong>抽象类</strong>实现接口，可以不用实现接口的方法</p></li><li><p>一个类同时可以实现多个接口</p></li><li><p><strong>接口中的属性</strong>只能是final的，而且是<strong>public static final</strong> 修饰符。比如</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">在接口中<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//实际上是public static final int a =1;（必须初始化）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>接口中属性的访问形式：接口名.属性名</p></li><li><p>一个接口不能继承其它的类，但是可以继承多个别的接口。接口和接口之间可以继承</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span><span class="token punctuation">,</span><span class="token class-name">C</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>接口的修饰符只能是public或者默认，这点和类的修饰符是一样的</p></li></ol><h4 id="实现接口-vs-继承类"><a href="#实现接口-vs-继承类" class="headerlink" title="实现接口 vs 继承类"></a>实现接口 vs 继承类</h4><p>接口和继承解决的问题不同</p><ul><li>接口的价值主要在于：解决代码的复用性和可维护性</li><li>接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法</li></ul><p>接口比继承更加灵活，继承需要满足 is-a 的关系，而接口只需满足 like-a 的关系</p><p>接口在一定程度上实现代码解耦 [即： 接口规范性+动态绑定]</p><h4 id="接口的多态性"><a href="#接口的多态性" class="headerlink" title="接口的多态性"></a>接口的多态性</h4><ol><li><p>多态参数</p></li><li><p>多态数组</p></li><li><p>多态接口传递</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterfacePoly</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">IF</span> if01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">IH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果IG 继承了 IH接口，而Teacher类实现了 IG接口</span>        <span class="token comment">//那么，实际上就相当于Teacher类也实现了 IH接口</span>        <span class="token comment">//这就是所谓的接口多态传递现象</span>        <span class="token class-name">IG</span> ig01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">IH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> IG<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">interface</span> IF <span class="token keyword">extends</span> IG<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> IH <span class="token keyword">implements</span> IF<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="类定义的进一步完善"><a href="#类定义的进一步完善" class="headerlink" title="类定义的进一步完善"></a>类定义的进一步完善</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220225110910353.png" alt="image-20220225110910353" style="zoom: 33%;" /></p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员[属性、方法、构造器、代码块、内部类]，内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p><h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">&#123;</span><span class="token comment">//外部类</span>    <span class="token keyword">class</span> inner<span class="token punctuation">&#123;</span><span class="token comment">//内部类</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Other</span><span class="token punctuation">&#123;</span><span class="token comment">//外部其他类 </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h4><p>定义在外部类局部位置上：</p><ul><li>局部内部类（有类名）</li><li><strong>匿名内部类</strong>（没有内部类，重点！）</li></ul><p>定义在外部类的成员位置上：</p><ul><li>成员内部类（没有static修饰）</li><li>静态内部类（使用static修饰）</li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p><ol><li>可以直接访问外部类的所有成员，包括私有的</li><li>不能添加访问修饰符，但是可以使用<code>final</code>修饰。因为它的地位就是一个局部变量，局部变量不能使用修饰符</li><li><strong>作用域</strong>：仅仅在定义它的方法或代码块中</li><li>局部内部类—-访问—-&gt;外部类的成员 【访问方式：直接访问】</li><li>外部类—-访问—-&gt;局部内部类的成员 【访问方式：创建对象，再访问（注意：必须在作用域内）】</li><li>外部其他类—-<strong>不能访问</strong>—-&gt;局部内部类（因为局部内部类地位是一个<strong>局部变量</strong>）</li><li>如果外部类和局部内部类的成员重名时，默认遵循<strong>就近原则</strong>，如果想访问外部类的成员，则可以使用<code>外部类名.this.成员</code>去访问</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LocalInnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Outer02</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//方法</span>        <span class="token keyword">class</span> <span class="token class-name">Inner02</span> <span class="token punctuation">&#123;</span><span class="token comment">//局部内部类，本质还是一个类</span>            <span class="token comment">//可以直接访问外部类的所有成员，包含私有的</span>            <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//局部内部类可以直接访问外部类的成员，例如n1和m2</span>                <span class="token comment">//如果外部类和局部内部类的成员重名时，默认遵循就近原则</span>                <span class="token comment">//如果想访问外部类的成员，则可以使用`外部类名.this.成员`去访问</span>                <span class="token comment">//Outer02.this 表示的本质就是外部类的对象，即哪个对象调用了m1，Outer02.this就是哪个对象</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"n1="</span> <span class="token operator">+</span> n1 <span class="token operator">+</span> <span class="token string">"外部类的n1="</span> <span class="token operator">+</span><span class="token class-name">Outer02</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//需要创建Outer类的对象再进行访问</span>        <span class="token class-name">Outer02</span> outer02 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>outer02<span class="token punctuation">.</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="匿名内部类-重点"><a href="#匿名内部类-重点" class="headerlink" title="匿名内部类(重点)"></a>匿名内部类(重点)</h4><p>（1）本质是类 （2）内部类 （3）该类没有名字 （4）同时还是一个对象</p><p>匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名的内部类</p><ol><li><p>匿名内部类的基本语法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> 类或接口<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    类体<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>匿名内部类的语法比较奇特，请注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码的分析可以看出这个特点，因此可以调用匿名内部类的的方法。</p></li><li><p>可以直接访问外部类的所有成员，包含私有的</p></li><li><p>不能添加访问修饰符，因为他的地位就是一个局部变量</p></li><li><p>作用域：仅仅在定义它的方法或者代码块中</p></li><li><p>匿名内部类—-访问——&gt;外部类成员[访问方式：直接访问]</p></li><li><p>外部其他类—-不能访问——&gt;匿名内部类（因为 匿名内部类地位是一个局部变量）</p></li><li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循<strong>就近原则</strong>，如果想访问外部类的成员，则可以使用（<code>外部类名.this.成员</code>）去访问</p></li><li><p>匿名内部类包含了继承、多态、动态绑定、内部类的知识</p></li></ol><h5 id="匿名内部类实践"><a href="#匿名内部类实践" class="headerlink" title="匿名内部类实践"></a>匿名内部类实践</h5><p>当作实参传递，简洁高效</p><p><a href="https://github.com/Bixlku/JavaStudyCode/tree/main/AnonymousInnerClass">匿名内部类示例代码</a></p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p><ol><li><p>可以<strong>直接访问</strong>外部类的所有成员，包括私有的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Outer01</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">class</span> <span class="token class-name">Inner01</span><span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用cry方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>可以添加任意访问修饰符(public、private、默认、protected)，因为它的定义也是一个成员</p></li><li><p>作用域和外部类的其他成员一样，为<strong>整个类体</strong>。在外部类的成员方法中创建成员内部类对象，再调用方法</p></li><li><p>成员内部类—-访问——&gt;外部类成员[访问方式：直接访问]</p></li><li><p>外部类—-访问——&gt;内部类（访问方式：创建对象，再访问）</p></li><li><p>外部其他类—-访问——&gt;成员内部类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Outer08</span> outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer08</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//第一种方式，相当于把new Inner()当作是outer的成员，只是语法，不需要太仔细想</span>    <span class="token class-name">Outer08<span class="token punctuation">.</span>Inner</span> inner1 <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一种外部其他类访问成员内部类的方方式</span>    <span class="token comment">//第二种方式，在外部类中，编写一个方法，可以返回Inner对象</span>    <span class="token class-name">Outer08<span class="token punctuation">.</span>Inner</span> inner2 <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token function">getInnerInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二种外部其他类访问成员内部类的方方式</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Outer08</span><span class="token punctuation">&#123;</span><span class="token comment">//外部类</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">&#123;</span><span class="token comment">//内部类</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> in <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用Inner的say方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token class-name">Inner</span> <span class="token function">getInnerInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循<strong>就近原则</strong>，如果想访问外部类的成员，则可以使用（<code>外部类名.this.成员</code>）去访问</p></li></ol><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类是定义在外部类的成员位置，并且有static修饰</p><ol><li><p>可以直接访问外部类的所有静态成员，包括私有的，但不能直接访问<strong>非静态成员</strong></p></li><li><p>可以添加任意访问修饰符，因为它的地位就是一个成员</p></li><li><p>作用域：同其他的成员，为整个整体</p></li><li><p>静态内部类—-访问——&gt;外部类成员[访问方式：直接访问]</p></li><li><p>外部类—-访问——&gt;静态内部类（访问方式：创建对象，再访问）</p></li><li><p>外部其他类—-访问——&gt;静态内部类（因为 匿名内部类地位是一个局部变量）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerClass</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Outer01</span> outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//方式1. 因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）</span>        <span class="token class-name">Outer01<span class="token punctuation">.</span>Inner01</span> inner01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer01<span class="token punctuation">.</span>Inner01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        inner01<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//方式2. 编写一个方法，可以返回静态内部类的实例</span>        <span class="token class-name">Outer01<span class="token punctuation">.</span>Inner01</span> inner01Instance <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token function">getInner01Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用非静态方法</span>        <span class="token class-name">Outer01<span class="token punctuation">.</span>Inner01</span> inner01Instance_ <span class="token operator">=</span> <span class="token class-name">Outer01</span><span class="token punctuation">.</span><span class="token function">getInner01Instance_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用静态方法（如果不想创建一个外部对象可以直接这样用类名）</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Outer01</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner01</span><span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用静态内部类的say方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Inner01</span> <span class="token function">getInner01Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Inner01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token class-name">Inner01</span> <span class="token function">getInner01Instance_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Inner01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循<strong>就近原则</strong>，如果想访问外部类的成员，则可以使用（<code>外部类名.成员</code>）去访问</p></li></ol><h2 id="第11章-枚举和注解"><a href="#第11章-枚举和注解" class="headerlink" title="第11章 枚举和注解"></a>第11章 枚举和注解</h2><h3 id="枚举-enumeration"><a href="#枚举-enumeration" class="headerlink" title="枚举(enumeration)"></a>枚举(enumeration)</h3><h4 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h4><ol><li>构造器私有化</li><li>本类内部创建一组对象</li><li>对外暴露对象（通过为对象添加访问修饰符）</li><li>可以提供get方法，但是不提供set方法</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Enumeration01</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Season</span><span class="token punctuation">.</span>AUTUMN<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Season</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> desc<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Season</span> SPRING <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Season</span><span class="token punctuation">(</span><span class="token string">"春天"</span><span class="token punctuation">,</span><span class="token string">"温暖"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Season</span> SUMMER <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Season</span><span class="token punctuation">(</span><span class="token string">"夏天"</span><span class="token punctuation">,</span><span class="token string">"炎热"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Season</span> AUTUMN <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Season</span><span class="token punctuation">(</span><span class="token string">"秋天"</span><span class="token punctuation">,</span><span class="token string">"萧瑟"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Season</span> WINTER <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Season</span><span class="token punctuation">(</span><span class="token string">"冬天"</span><span class="token punctuation">,</span><span class="token string">"寒冷"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Season</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>desc <span class="token operator">=</span> desc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getDesc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> desc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h4><ol><li>使用关键字enum替代class</li><li>SPRING(“春天”,”温暖”) 解读 常量名(实参列表)</li><li>如果使用enum来实现枚举，枚举对象应当写在前面</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Enumeration02</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Season</span><span class="token punctuation">.</span>AUTUMN<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">enum</span> <span class="token class-name">Season1</span> <span class="token punctuation">&#123;</span>    <span class="token function">SPRING</span><span class="token punctuation">(</span><span class="token string">"春天"</span><span class="token punctuation">,</span><span class="token string">"温暖"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">SUMMER</span><span class="token punctuation">(</span><span class="token string">"夏天"</span><span class="token punctuation">,</span><span class="token string">"炎热"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">AUTUMN</span><span class="token punctuation">(</span><span class="token string">"秋天"</span><span class="token punctuation">,</span><span class="token string">"萧瑟"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">WINTER</span><span class="token punctuation">(</span><span class="token string">"冬天"</span><span class="token punctuation">,</span><span class="token string">"寒冷"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> desc<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">Season1</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>desc <span class="token operator">=</span> desc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getDesc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> desc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="enum关键字实现枚举的注意事项"><a href="#enum关键字实现枚举的注意事项" class="headerlink" title="enum关键字实现枚举的注意事项"></a>enum关键字实现枚举的注意事项</h5><ol><li>当使用enum关键字开发一个枚举类时，默认会<strong>继承Enum类</strong>（使用javap验证）</li><li><code>final public static Season SPRING = new Season(&quot;春天&quot;,&quot;温暖&quot;);</code>   简化为  <code>SPRING(&quot;春天&quot;,&quot;温暖&quot;),</code>这里必须理解其调用的是哪个构造器</li><li>如果使用无参构造器 创建 枚举对象，则实参列表的小括号可以省略</li></ol><h5 id="enum常用方法说明"><a href="#enum常用方法说明" class="headerlink" title="enum常用方法说明"></a>enum常用方法说明</h5><div class="table-container"><table><thead><tr><th>方法名</th><th>详细描述</th></tr></thead><tbody><tr><td>valueOf</td><td>传递枚举类型的Class对象和枚举常量名称给<strong>静态方法</strong>valueOf，会得到与参数匹配的枚举常量。将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常。</td></tr><tr><td>toString</td><td>得到当前枚举常量的名称。你可以通过重写这个方法来使得到的结果更易读</td></tr><tr><td>equals</td><td>在枚举类型中可以直接使用<code>==</code>来比较两个枚举常量是否相等。Enum提供的这个<code>equals0</code>方法，也是直接使用<code>==</code>实现的。它的存在是为了在Set、List和Map中使用。注意，equals()是不可变的。</td></tr><tr><td>hashCode</td><td>Enum实现了hashCode()来和equals0保持一致。它也是不可变的。</td></tr><tr><td>getDeclaringClass</td><td>得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属于同一个枚举类型。</td></tr><tr><td>name</td><td>得到当前枚举常量的名称。建议优先使用toString()。</td></tr><tr><td>ordinal</td><td>得到当前枚举常量的次序。</td></tr><tr><td>compareTo</td><td>枚举类型实现了Comparable接口，这样可以比较两个枚举常量，比较的是编号（按照声明的顺序排列）</td></tr><tr><td>clone</td><td>枚举类型不能被Clone.。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone()。</td></tr><tr><td>values</td><td>含有定义的所有枚举对象（是个数组）</td></tr></tbody></table></div><h3 id="注解-annotation"><a href="#注解-annotation" class="headerlink" title="注解(annotation)"></a>注解(annotation)</h3><p>注解也被称为元数据，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。和注释一样，注解不影响程序逻辑，但注解可以被编译或者运行，相当于前在代码中的补充信息。</p><ol><li>@Override： 限定某个方法，是重写父类方法，该注解只能用于方法</li><li>@Deprecated： 用于表示某个程序元素（类，方法等）已过时<ol><li>过时不代表不能使用，只是不推荐使用</li><li>可以修饰方法、类、字段、包、参数 等等</li><li>@Deprecated可以用于版本升级，过渡使用</li></ol></li><li>@SuppressWarnings： 抑制编译器警告<ol><li>在大括号中可以抑制不希望看到的警告信息，例如 <code>@SuppressWarnings(&#123;&quot;all&quot;&#125;)</code>，警告类型很多，具体的话查文档</li><li>@SuppressWarnings 作用范围和放置位置有关，可以放在类上，也可以放在方法上</li></ol></li></ol><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解本身作用不大，在看源代码的时候看得懂就行</p><h2 id="第12章-异常"><a href="#第12章-异常" class="headerlink" title="第12章 异常"></a>第12章 异常</h2><p>创建try-catch代码块的快捷键：<code>ctrl</code>+<code>alt</code>+<code>windows</code>+<code>T</code></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Java语言中，将程序中出现的不正常情况称为异常 。</p><h3 id="异常事件分类"><a href="#异常事件分类" class="headerlink" title="异常事件分类"></a>异常事件分类</h3><ol><li><p><strong>Error</strong>（错误）：Java虚拟机无法解决的严重问题</p></li><li><p><strong>Exception</strong>（异常）：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。Exception也分为两个大类</p><ol><li><strong>运行时异常</strong>RuntimeException（运行时发生的异常）有默认处理机制</li><li><strong>编译时异常</strong>（编译时，编译器检查出的异常）</li></ol></li></ol><h3 id="🚩异常体系图"><a href="#🚩异常体系图" class="headerlink" title="🚩异常体系图"></a>🚩异常体系图</h3><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230907164845191.png" alt="异常体系图（实线继承，虚线实现）"></p><p>运行时异常是编译器检查不出来的异常，可不做处理，因为这类异常很普遍</p><p>编译时异常是编译器要求必须处置的异常</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li><p><strong>try-catch-finally</strong></p><p>程序员在代码中捕获发生的异常，自行处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//检测到异常</span>    <span class="token comment">//系统将异常封装成Exception对象e，传递给catch</span>    <span class="token comment">//得到异常对象后，程序员自己处理</span>    <span class="token comment">//没有发生异常时，catch代码块不执行</span><span class="token punctuation">&#125;</span><span class="token keyword">finally</span><span class="token punctuation">&#123;</span>    <span class="token comment">//不管try代码是否有异常发生，是重要执行finally</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>throws</strong></p><p>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p></li></ol><p>try-catch-finally和throws二选一，若未写明，则默认使用throws</p><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求<strong>父类异常在后，子类异常在前</strong>，例如：Exception在后，NullPionterException在前。如果发生异常，只会匹配其中的一个catch</p><p>try-finally可以配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉。应用场景：执行一段代码，不管是否发生异常，都必须执行某个业务逻辑</p><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><ol><li>如果一个方法可能产生某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理</li><li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处f2()在写代码时会报错，因为FileNotFoundException是编译时异常</span>    <span class="token comment">//此处有两种选择，1.对f2()代码块进行try-catch。</span>    <span class="token comment">//2.继续向上抛出FileNotFoundExecption异常</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">FileNotFoundException</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">f4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处在写代码时不会报错，因为ArithmeticException是运行时异常，不要求程序员显示处理，其有默认处理机制</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">f4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ArithmeticException</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这是可以自己设计异常类，用于描述该错误信息。</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>定义类：自定义异常类名（程序员自己写）继承Exception或RuntimeException</li><li>如果继承Exception，属于编译异常</li><li>如果继承RuntimeException，属于运行异常</li></ol><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol><li>自定义异常一般都是继承RuntimException</li><li>把自定义异常做成RuntimeException（运行时异常），可以使用默认的处理机制</li></ol><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230909225418378.png" alt="image-20230909225418378" style="zoom:80%;" /></p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230909225459100.png" alt="image-20230909225459100" style="zoom:80%;" /></p><h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><h4 id="一览表"><a href="#一览表" class="headerlink" title="一览表"></a>一览表</h4><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20230910163535454.png" alt="image-20230910163535454"></p><h2 id="第13章-常用类"><a href="#第13章-常用类" class="headerlink" title="第13章 常用类"></a>第13章 常用类</h2><h3 id="包装类-Wrapper"><a href="#包装类-Wrapper" class="headerlink" title="包装类 Wrapper"></a>包装类 Wrapper</h3><ol><li><p>针对八种基本数据类型相应的引用类型——包装类</p></li><li><p>有了类的特点，就可以调用类中的方法</p></li></ol><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table></div><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230915142938465.png" alt="继承关系" style="zoom: 67%;" /></p><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230915143030998.png" alt="继承关系" style="zoom:80%;" /></p><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230915143048622.png" alt="继承关系" style="zoom:80%;" /></p><h4 id="包装类和基本数据的转换"><a href="#包装类和基本数据的转换" class="headerlink" title="包装类和基本数据的转换"></a>包装类和基本数据的转换</h4><ol><li><p><strong>装箱</strong>：基本类型-&gt;包装类型；<strong>拆箱</strong>：包装类型-&gt;基本类型</p></li><li><p>jdk5（包括jdk5）以后都是自动装箱和自动拆箱</p></li><li><p>自动装箱底层调用的是valueOf()方法，例如：Integer.valueOf()</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//手动装箱</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//手动装箱方法1</span><span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//手动装箱方法2</span><span class="token comment">//手动拆箱</span><span class="token keyword">int</span> i <span class="token operator">=</span> integer<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//jdk5后，自动装箱和自动拆箱</span><span class="token keyword">int</span> n2 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token comment">//自动装箱</span><span class="token class-name">Integer</span> integer2 <span class="token operator">=</span> n2<span class="token punctuation">;</span><span class="token comment">//底层是用的是Integer.valueOf(n2)</span><span class="token comment">//自动拆箱</span><span class="token keyword">int</span> n3 <span class="token operator">=</span> integer2<span class="token punctuation">;</span><span class="token comment">//底层是用的是intValue()方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="包装类型和String类型的相互转换"><a href="#包装类型和String类型的相互转换" class="headerlink" title="包装类型和String类型的相互转换"></a>包装类型和String类型的相互转换</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//包装类(Integer)->String</span><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token comment">//方式1</span><span class="token class-name">String</span> str <span class="token operator">=</span> i <span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span><span class="token comment">//方式2</span><span class="token class-name">String</span> str1 <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//方式3</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//String->包装类(Integer)</span><span class="token class-name">String</span> str4 <span class="token operator">=</span> <span class="token string">"114514"</span><span class="token punctuation">;</span><span class="token comment">//方式1</span><span class="token class-name">Integer</span> integer1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动装箱</span><span class="token comment">//方式2</span><span class="token class-name">Integer</span> integer2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>str4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造器。已经是Deprecated了，官方不建议</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span><span class="token comment">//返回最小值</span><span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token comment">//返回最大值</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断是不是数字</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isLetter</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断是不是字母</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断是不是大写</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isLowerCase</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断是不是小写</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isWhitespace</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断是不是空格</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//转换成大写</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//转换成小写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Integer类的范围提示"><a href="#Integer类的范围提示" class="headerlink" title="Integer类的范围提示"></a>Integer类的范围提示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> n1 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> n2 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n1<span class="token operator">==</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里输出true</span><span class="token class-name">Integer</span> n3 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> n4 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n3<span class="token operator">==</span>n4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里输出false</span><span class="token comment">//因为Integer类的源码中，-127-127范围内返回的都是int，而范围外返回的都是new的对象</span><span class="token comment">//只要==的两边有基本数据类型，那么对比的一定是值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="🚩String"><a href="#🚩String" class="headerlink" title="🚩String"></a>🚩String</h3><ol><li><p>String类用于存储字符串，即一组字符序列</p></li><li><p>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p></li><li><p>String类常用构造器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">;</span><span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token class-name">String</span> original<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> startIndex<span class="token punctuation">,</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>String是final类，<strong>不能</strong>被其他的类<strong>继承</strong></p></li><li><p>String有属性 private final char value[];用于存放字符串内容</p></li><li><p>一定要注意：value是一个final类型，不可以修改（final不可修改指的是<strong>不能指向新的地址</strong>，但是<strong>单个字符</strong>的内容是可以变化的）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"jack"</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'c'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> v2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'t'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">'m'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>value<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'H'</span><span class="token punctuation">;</span><span class="token comment">//此处不报错</span>value <span class="token operator">=</span> v2<span class="token punctuation">;</span><span class="token comment">//此处报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Serializable：实现了串行化，说明可以在网络中传输</p><p>Comparable：实现了Comparable接口，说明String对象可以比较大小</p><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230916101911861.png" alt="image-20230916101911861"></p></li></ol><h4 id="创建String对象的两种方式"><a href="#创建String对象的两种方式" class="headerlink" title="创建String对象的两种方式"></a>创建String对象的两种方式</h4><ol><li><p>直接赋值 <code>String s = &quot;hspedu&quot;</code>。只要不是new出来的，就都会直接放在方法区里面，不会进堆</p><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230916112013487.png" alt="image-20230916112013487"></p></li><li><p>调用构造器 <code>String s2 = new String(&quot;hsp&quot;);</code></p><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230916112030189.png" alt="image-20230916112030189"></p></li></ol><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230917143702258.png" alt="image-20230917143702258"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//equals方法比较的是值，所以这里是True</span>s <span class="token operator">==</span> s2<span class="token punctuation">;</span><span class="token comment">//这里是False，因为s2指向堆，而s指向常量池</span><span class="token comment">//.intern()方法返回的是常量池的地址</span><span class="token comment">//It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.</span>s <span class="token operator">==</span> s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处返回的是True</span>s <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处返回的是False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="关于-intern-方法的小练习："><a href="#关于-intern-方法的小练习：" class="headerlink" title="关于.intern()方法的小练习："></a>关于<code>.intern()</code>方法的小练习：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Runoob"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Runoob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> str3 <span class="token operator">=</span> str2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其文字解释为：</p><p>以上实例中，str1 是直接赋值的字符串常量，它会被自动添加到字符串池中。str2 是通 过new String() 创建的新字符串对象，它不会自动添加到字符串池中。然后，通过调用 intern() 方法，将 str2 添加到字符串池中，并返回字符串池中的引用，保存在 str3 中。</p><p>注意，== 运算符用于比较引用是否相等。在上面的示例中，str1 == str3 返回 true，这是因为它们都引用字符串池中的同一个对象。</p><p>其图像解释为：</p><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/e717021464726c7b4b32792e037889e.png" alt="e717021464726c7b4b32792e037889e" style="zoom:80%;" /></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WrapperType02</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>        <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//True</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name <span class="token operator">==</span> p2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//True</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//True</span>        <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//False</span>        <span class="token comment">//搞清楚内存分布图</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串特性"><a href="#字符串特性" class="headerlink" title="字符串特性"></a>字符串特性</h4><ol><li>编译器会自动进行优化，判断创建的常量池对象，例如<code>String a = &quot;hello&quot; + &quot;world&quot;</code>会直接优化成<code>String a = &quot;helloworld&quot;</code>。所以只会创建一个对象。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token class-name">String</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token comment">//c=a+b这里是有讲究的</span><span class="token comment">//1. 先创建一个StringBuilder sb = StringBuilder()</span><span class="token comment">//2. 执行 sb.append("hello");</span><span class="token comment">//3. sb.append("abc")</span><span class="token comment">//4. 相当于String c = sb.toString()</span><span class="token comment">//最后其实是c指向堆中的对象</span><span class="token class-name">String</span> d <span class="token operator">=</span> <span class="token string">"helloabc"</span>d <span class="token operator">==</span> c<span class="token comment">//返回False，因为c指向的是堆中的对象，而d直接指向池中的对象</span><span class="token class-name">String</span> e <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"abc"</span>e <span class="token operator">==</span> d<span class="token comment">//返回True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="练习题：画出下图的内存布局图"><a href="#练习题：画出下图的内存布局图" class="headerlink" title="练习题：画出下图的内存布局图"></a>练习题：画出下图的内存布局图</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ch <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token char">'j'</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'v'</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Test1</span> ex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          ex<span class="token punctuation">.</span><span class="token function">change</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span>str<span class="token punctuation">,</span>ex<span class="token punctuation">.</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span>str<span class="token operator">+</span><span class="token string">" and "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ch<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        str <span class="token operator">=</span> <span class="token string">"java"</span><span class="token punctuation">;</span>        ch<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'h'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/image-20230918114742030.png" alt="内存布局图" style="zoom:80%;" /></p><h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><p>String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低。因此开发者设计了StringBuilder和StringBuffer来增强String的功能</p><ul><li><code>equals</code> 区分大小写判断内容是否相等</li><li><code>equalsIgnoreCase</code> 忽略大小写判断内容是否相等</li><li><code>length</code> 获取字符的个数</li><li><code>indexOf</code> 获取字符串中第一次出现的索引，索引从0开始，如果找不到，就返回-1</li><li><code>lastIndexOf</code> 获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，就返回-1</li><li><code>substring</code> 截取指定范围内的子串</li><li><code>trim</code> 去掉前后空格</li><li><code>charAt</code> 获取某索引处的字符，注意没有<code>str[index]</code>这种形式 </li><li><code>toUpperCase</code> 变成大写字符</li><li><code>toLowerCase</code> 变成小写字符</li><li><code>concat</code> 拼接字符串</li><li><code>replace</code> 替换字符串中的字符</li><li><code>split</code> 分割字符串</li><li><p><code>compareTo</code> 比较两个字符串的大小（不懂的话建议去看源码）</p><ol><li>返回值为0时，说面两个字符串相等</li><li>若前者大，则返回正数；若后者大，则返回负数</li></ol></li><li><code>toCharArray</code> 转换成字符数组</li><li><code>format</code> 格式字符串（类c写法）</li></ul><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20230919141502.png" alt="20230919141502"></p><ol><li>StringBuffer的直接父类是AbstractBuilder</li><li>StringBuffer实现了Serialzable，即StringBuffer的对象可以串行化</li><li><p>在父类中 AbstractStringBuilder有属性byte[] value，不是final。该value数组存放字符内容，引出存放在堆中。</p><p>从jdk9开始char[]被改为了byte[]，因为AbstractStringBuilder大部分情况下存放的都是拉丁字母，使用Byte的话一个拉丁字母只需要占据1个字节的容量，所以现在使用非拉丁字母时，使用UTF-16编码，需要使用isLatin1进行区分</p></li><li>StringBuilder类是一个final类，不能被继承</li><li>StringBuilder的字符内容存放在byte[] value中，所以更改后不是每次都要变换地址（如果空间不够还是会改变地址的）</li></ol><h3 id="String-VS-StringBuffer"><a href="#String-VS-StringBuffer" class="headerlink" title="String VS StringBuffer"></a>String VS StringBuffer</h3><ol><li>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低//<code>private final char value[]</code></li><li>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次都更新地址，所以效率比较高。//<code>char[] value</code> //这个放在堆中</li></ol><h3 id="StringBuffer构造器"><a href="#StringBuffer构造器" class="headerlink" title="StringBuffer构造器"></a>StringBuffer构造器</h3><ol><li><code>StringBuffer()</code> 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符。</li><li><code>StringBuffer(CharSequence seq)</code> 构造一个字符串缓冲区，它包含与指定的 CharSequence 相同的字符。</li><li><code>StringBuffer(int capacity)</code> 构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char［］大小进行指定</li><li><code>StringBuffer(String str)</code> 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。其cahr[]大小为str.length()+16</li></ol><h3 id="StringBuffer转换"><a href="#StringBuffer转换" class="headerlink" title="StringBuffer转换"></a>StringBuffer转换</h3><p>String -&gt; StringBuffer</p><ol><li><p>使用构造器</p> <pre class="line-numbers language-none"><code class="language-none">StringBuffer sb &#x3D; new StringBuffer(str);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用append()方法</p> <pre class="line-numbers language-none"><code class="language-none">StringBuffer sb &#x3D; new StringBuffer(); sb &#x3D; sb.append(str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>StringBuffer -&gt; String</p></li><li><p>使用StringBuffer提供的toString方法</p> <pre class="line-numbers language-none"><code class="language-none">String s &#x3D; sb.toString()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用构造器</p> <pre class="line-numbers language-none"><code class="language-none">String s1 &#x3D; new String(sb);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="StringBuffer的常用方法"><a href="#StringBuffer的常用方法" class="headerlink" title="StringBuffer的常用方法"></a>StringBuffer的常用方法</h3><ol><li><code>append</code> 增</li><li><code>delete(start,end)</code> 删</li><li><code>replace(start,end,string)</code> 改。将start-end区间的内容替换为string</li><li><code>indexOf</code> 查</li><li><code>insert(index,str)</code> 在index处插入str，原来索引为index的元素自动后移</li><li><code>length</code> 获取长度</li></ol><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><ol><li>可变字符序列，使用与StringBuffer兼容的API ，但是不保证同步（不是线程安全的）。用作StringBuffer的简易替换，用在字符串缓冲区被单线程使用的时候。如果可能建议使用该类，因为其比StringBuffer要快</li><li>StringBuilder的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据</li></ol><h3 id="String、StingBuffer、StringBuilder比较"><a href="#String、StingBuffer、StringBuilder比较" class="headerlink" title="String、StingBuffer、StringBuilder比较"></a>String、StingBuffer、StringBuilder比较</h3><ol><li>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</li><li>String：不可变字符序列，效率低，但是复用率高。如果需要对String进行大量修改，就不要使用String，应当选择StringBuffer和StringBuilder</li><li>StringBuffer：可变字符序列、效率较高（增删）、线程安全</li><li>StringBuilder：可变字符序列、效率最高、线程不安全</li></ol><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>常用的<strong>静态方法</strong></p><ol><li><code>abs()</code> 求绝对值</li><li><code>pow()</code> 求幂</li><li><code>ceil()</code> 向上取整</li><li><code>floor()</code> 向上取整</li><li><code>round()</code> 四舍五入</li><li><code>sqrt()</code> 求开方</li><li><code>random()</code> 求随机数，返回一个[0,1)的随机小数</li><li><code>max()</code> 求两个数的最大值</li><li><code>min()</code> 求两个数的最小值</li></ol><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><ol><li><code>Arrays.toString()</code> 显示数组</li><li><p><code>Arrays.sort()</code> 排序 </p><ul><li><p>因为数组是引用类型，所以通过sort排序后，会直接影响到实参arr。</p></li><li><p>sort是重载的，也可以通过传入一个接口 Comparator 实现定制排序</p></li><li><p>定制排序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o1<span class="token punctuation">,</span> <span class="token class-name">Object</span> o2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        相关程序代码        <span class="token keyword">return</span> int1<span class="token operator">-</span>int2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入两个参数：</p><p>（1） 排序的数组<code>arr</code></p><p>（2）实现了Comparator接口的匿名内部类，要求其实现compare方法。其底层调用了<strong>二叉排序</strong>，compare方法返回的int值的正负会直接影响排序是从小到大还是从大到小。如果i1-i2则为从小到大，反之则为从大到小</p></li></ul></li><li><p><code>Arrays.binarySearch()</code> 通过二分搜索法进行查找，要求数组有序</p></li><li><p><code>copyOf</code> 数组元素的复制 </p><p> <code>Integer[] newArr = Arrays.copyOf(arr,arr.length)</code> 从arr数组中，拷贝arr.length个元素到newArr数组中。如果拷贝的长度大于arr.length，就在新数组后面加null；如果拷贝的长度小于0，就抛出异常NegativeArraySizeException。</p></li><li><p><code>Arrays.fill(arr,element)</code> 数组填充。将所有元素替换为element</p></li><li><p><code>Arrays.equals(arr1,arr2)</code> 比较两个数组的内容是否完全一致</p></li><li><p><code>Arrays.asList()</code> 将一组值，转换为list。</p></li></ol><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><ol><li><code>exit</code> 退出当前程序</li><li><code>arraycopy()</code> 复制数组元素，适合底层调用。一般选用<code>Arrays.copyOf()</code>，其底层调用的就是<code>arraycopy()</code></li><li><code>currentTimeMillens()</code> 返回当前时间距离1970-1-1的毫秒数</li><li><code>gc</code> 运行垃圾回收机制 System.gc()</li></ol><h3 id="BigInteger和BigDecimal类"><a href="#BigInteger和BigDecimal类" class="headerlink" title="BigInteger和BigDecimal类"></a>BigInteger和BigDecimal类</h3><p>应用场景：</p><ol><li><p>BigInteger适合保存比较大的整型</p></li><li><p>BigDecimal适合保存进度更高的浮点型（小数）</p></li></ol><p>对BigInteger或BigDecimal进行加减乘除时，不能直接写运算符号，而应该调用对应的方法</p><p>在调用devide方法时，需要指定精度，即BigDecimal.ROUND_CEILING。其精度与分子相同</p><h2 id="第14章-集合"><a href="#第14章-集合" class="headerlink" title="第14章 集合"></a>第14章 集合</h2><h3 id="集合的理解和好处"><a href="#集合的理解和好处" class="headerlink" title="集合的理解和好处"></a>集合的理解和好处</h3><p>数组：</p><ol><li>长度开始时必须指定，而且一旦指定，不能修改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行增加/删除元素 比较麻烦</li></ol><p>集合：</p><ol><li>可以动态保存任意多个对象，使用方便</li><li>提供一系列方便的操作对象的方法：add、remove、set、get</li><li>使用集合添加、删除元素比较间接</li></ol><h3 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h3><p>必背</p><h4 id="Collection：单列集合"><a href="#Collection：单列集合" class="headerlink" title="Collection：单列集合"></a>Collection：单列集合</h4><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20230924170531.png" alt="20230924170531"></p><h4 id="Map：双列集合"><a href="#Map：双列集合" class="headerlink" title="Map：双列集合"></a>Map：双列集合</h4><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20230924170449.png" alt="20230924170449"></p><h3 id="Collection接口和常用方法"><a href="#Collection接口和常用方法" class="headerlink" title="Collection接口和常用方法"></a>Collection接口和常用方法</h3><h4 id="Collection接口实现类的特点"><a href="#Collection接口实现类的特点" class="headerlink" title="Collection接口实现类的特点"></a>Collection接口实现类的特点</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>Collection实现子类可以存放多个元素，每个元素可以是Object</li><li>有些Collection实现类可以存放重复元素，有些不能；有些是有序的（List），有些是无序的（Set）</li><li>Collection接口<strong>没有直接</strong>的子类，是通过它的子接口Set和List来实现的</li></ol><h4 id="使用ArrayList演示常用方法"><a href="#使用ArrayList演示常用方法" class="headerlink" title="使用ArrayList演示常用方法"></a>使用ArrayList演示常用方法</h4><ol><li><code>add</code>： 添加单个元素（有自动装箱功能）</li><li><code>remove</code>： 删除指定元素<br> <code>list.remove(int index)</code>删除序列为index的元素<br> <code>list.remove(Object o)</code>删除指定元素的第一个出现。 如果不包含该元素，则不会更改。</li><li><code>contains</code>：查找元素是否存在</li><li><code>size</code>：获取元素个数</li><li><code>isEmpty</code>：判断是否为空</li><li><code>clear</code>：清空</li><li><code>addAll</code>：添加多个元素</li><li><code>containsAll</code>：查找多个元素是否都存在</li><li><code>removeAll</code>：删除多个元素</li></ol><h4 id="Collection接口遍历元素方式"><a href="#Collection接口遍历元素方式" class="headerlink" title="Collection接口遍历元素方式"></a>Collection接口遍历元素方式</h4><ol><li><p>使用Iterator（迭代器）</p><ul><li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</li><li>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator()接口的对象，即可以返回一个迭代器</li><li>使用Iterator.next()之前，必须先用hasNext()，否则可能会抛出NoSuchElementException</li><li>如果希望再次遍历，需要重置迭代器</li></ul></li><li><p>增强for循环</p><p> 增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样。只能用于遍历集合或数组。</p><p> 基本语法</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>元素类型 元素名<span class="token operator">:</span>集合名或数组名<span class="token punctuation">)</span>    访问元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 实际上增强for循环底层就是调用了iterator的next()。可以理解为简化版本的迭代器遍历。</p><p> 快捷方式：<code>I</code></p></li></ol><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ol><li>List集合类中元素有序（即添加顺序和去除顺序一致）、且可重复</li><li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</li><li>实现List接口的实现类有很多，常见的有ArrayList、LinkedList和Vector</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li><p><code>void add(int index, Object ele)</code> 在index位置插入ele元素</p></li><li><p><code>boolean addAll(int index, Collection eles)</code> 从index位置开始将eles中的所有元素都添加进来</p></li><li><p><code>Object get(int index)</code> 获取指定index位置的元素</p></li><li><p><code>int indexOf(Object obj)</code> 返回obj在集合中首次出现的位置</p></li><li><p><code>int lastIndexOf(Object obj)</code> 返回obj在当前集合中末次出现的位置</p></li><li><p><code>Object remove(int index)</code> 移除指定index位置的元素，并返回此元素</p></li><li><p><code>Object set(int index, Object ele)</code> 设置指定index位置的元素为ele，相当于是替换</p></li><li><p><code>List subList(int fromIndex, int toIndex)</code> 返回从fromIndex到toIndex位置的子集</p></li></ol><h3 id="ArrayList的注意事项"><a href="#ArrayList的注意事项" class="headerlink" title="ArrayList的注意事项"></a>ArrayList的注意事项</h3><ol><li><p>permits all elements, including null, ArrayList 可以加入null，并且支持加入多个null</p></li><li><p>ArrayList底层是基于数组实现的</p></li><li><p>ArrayList基本等同于Vector，但是ArrayList是线程不安全的；在多线程情况下不建议使用ArrayList</p></li></ol><h3 id="ArrayList底层结构和源码分析"><a href="#ArrayList底层结构和源码分析" class="headerlink" title="ArrayList底层结构和源码分析"></a>ArrayList底层结构和源码分析</h3><ol><li><p>ArrayList中维护了一个Object[]类型的数组elementData。transient Object[] elementData; transient 短暂的、瞬间；表示该属性不会被序列化</p></li><li><p>创建ArrayList对象时，如果使用无参构造器，则初始化elementData容量为0，第一次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍大小</p></li><li><p>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</p></li></ol><h3 id="ArrayList和LinkedList的比较"><a href="#ArrayList和LinkedList的比较" class="headerlink" title="ArrayList和LinkedList的比较"></a>ArrayList和LinkedList的比较</h3><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20230926191930.png" alt="20230926191930"></p><p>一般来说，在程序中，80%-90%是改查，所以大部分情况下使用的是ArrayList</p><h3 id="Set接口和常用方法"><a href="#Set接口和常用方法" class="headerlink" title="Set接口和常用方法"></a>Set接口和常用方法</h3><h4 id="Set接口基本介绍"><a href="#Set接口基本介绍" class="headerlink" title="Set接口基本介绍"></a>Set接口基本介绍</h4><ol><li>无序（添加和取出的顺序不一样），虽然无序，但是<strong>固定顺序</strong>没有索引</li><li>不允许重复元素，所以最多包含一个null</li><li>JDK API中Set接口的实现类</li></ol><h4 id="Set接口常用方法"><a href="#Set接口常用方法" class="headerlink" title="Set接口常用方法"></a>Set接口常用方法</h4><p>和List接口一样，Set接口是Collection的子接口，所以常用方法和Collection接口一样</p><h4 id="Set接口的遍历方式"><a href="#Set接口的遍历方式" class="headerlink" title="Set接口的遍历方式"></a>Set接口的遍历方式</h4><p>和Collection遍历方式一致</p><ol><li>使用迭代器</li><li>增强for</li><li><strong>不能</strong>使用索引的方式</li></ol><h3 id="HashSet的全面说明"><a href="#HashSet的全面说明" class="headerlink" title="HashSet的全面说明"></a>HashSet的全面说明</h3><ol><li>HashSet实现了Set接口</li><li>HashSet底层实际上是HashMap</li><li>可以存放null值，但是只能有一个null</li><li>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果。即不保证取出和存入顺序一致</li><li>不能有重复元素/对象</li></ol><p>示例代码：<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Emploee</span> yyh <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Emploee</span><span class="token punctuation">(</span><span class="token string">"yyh"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Emploee</span> yyh1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Emploee</span><span class="token punctuation">(</span><span class="token string">"yyh"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HashSet</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>yyh<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回true</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>yyh1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处会返回false，因为hashcode和equals返回的值都是一样的</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Emploee</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Emploee</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//重写equals接口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token class-name">Emploee</span> emploee <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Emploee</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> emploee<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>age<span class="token punctuation">,</span> emploee<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//重写每一个Object类都有的hashCode接口</span>        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="Map接口和常用方法"><a href="#Map接口和常用方法" class="headerlink" title="Map接口和常用方法"></a>Map接口和常用方法</h3><ol><li>Map和Collection并列存在。用于保存具有映射关系的数据：Key-Value，即键值对</li><li>Map中的Key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</li><li>Map中的Key不允许重复，原因和HashSet一样，当<code>put()</code>的Key重复时，等价于替换</li><li>Map中的value可以重复</li><li>Map中的key可以为null，value也可以为null，注意key为null只能有一个，而value为null可以有多个</li><li><strong>常用</strong>String类作为Map的key</li><li>key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</li><li>Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，又因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"no1"</span><span class="token punctuation">,</span><span class="token string">"yyh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"no2"</span><span class="token punctuation">,</span><span class="token string">"yyh2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Set</span> set <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//static class Node&lt;K,V> implements Map.Entry&lt;K,V></span><span class="token comment">//k-v存放于HashMap$Node中，其代码格式为HashMap$Node node = newNode(hash,key,value,null)</span><span class="token comment">//entrySet集合的存在是为了方便程序员进行遍历，该集合存放的元素类型是Entry，一个Entry对象有k和v，即EntrySet&lt;Entry&lt;K,V>></span><span class="token comment">//entrySet中存放的是Entry，但是其实际上存放的是HashMap$Node。因为HashMap$Node实现了Entry接口，static class Node&lt;K,V> implements Map.Entry&lt;K,V></span><span class="token comment">//实际上Entry中的k和v都是指向Node的。只是指向！</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj <span class="token operator">:</span> set<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出class java.util.HashMap$Node</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="Map接口和常用方法-1"><a href="#Map接口和常用方法-1" class="headerlink" title="Map接口和常用方法"></a>Map接口和常用方法</h3><ol><li><code>put</code> 添加</li><li><code>remove</code> 根据键删除映射关系</li><li><code>get</code> 根据键获取值</li><li><code>size</code> 获取元素个数</li><li><code>isEmpty</code> 判断各户是否为0</li><li><code>clear</code> 清除</li><li><code>containsKey</code> 查找键是否存在</li></ol><h4 id="Map接口的遍历方法"><a href="#Map接口的遍历方法" class="headerlink" title="Map接口的遍历方法"></a>Map接口的遍历方法</h4><ol><li><code>containsKey</code> 查找键是否存在</li><li><code>keySet</code> 获取所有的键</li><li><code>entrySet</code> 获取所有关系</li><li><code>values</code> 获取所有的值</li></ol><p>第一组：先取出所有的key，通过key取出对应的Value<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Set</span> keyset <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(1)增强for循环</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key <span class="token operator">:</span> keyset<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//(2)迭代器</span><span class="token class-name">Iterator</span> iterator keyset<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//快捷键itit</span>    <span class="token class-name">Object</span> next <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>第二组：把所有的values取出来<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collection</span> values <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里可以使用所有的Collections使用的遍历方法</span><span class="token comment">//(1)增强for循环</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//(2)迭代器</span><span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//快捷键itit</span>    <span class="token class-name">Object</span> next <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>第三组：通过EntrySet来获取k-v<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//(1)增强for循环</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Object</span> entry <span class="token operator">:</span> entrySet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> m <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> entry<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> m<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//(2)迭代器</span><span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> entrySet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> next <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//HashMap$Node -实现-> Map.Entry(getKey,getValue)，HashMapNode没提供相应的方法。。。</span>    <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> m <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> entry<span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> m<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Java的反射是指程序在运行期可以得到一个对象的所有信息<br><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20231012161513.png" alt="20231012161513"></p><ol><li>Class也是类，因此也继承Object类 ［类图］</li><li>Class类对象不是new出来的，而是<strong>系统创建</strong>的［演示］</li><li>对于某个类的Class类对象，在内存中只有一份，因为类<strong>只加载一次</strong> ［演示］</li><li>对于每个类的实例都会记得自己是由哪个Class实例所生成的</li><li>通过Class对象可以完整地得到一个类的<strong>完整结构</strong>，通过一系列API</li><li>Class对象是存放在<strong>堆</strong>的</li><li>类的字节码二进制数据，是放在<strong>方法区</strong>的，有的地方称为类的元数据（包括 方法代码变量名，方法名，访问权限等等）</li></ol><h3 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a>Class类常用方法</h3><p>包中的Animal.java文件，其中包含了一个Animal Class，文件位置在com.yyh.class_<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yyh<span class="token punctuation">.</span>class_</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"cat"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> home <span class="token operator">=</span> <span class="token string">"Asia"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Animal&#123;"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token string">", home='"</span> <span class="token operator">+</span> home <span class="token operator">+</span> <span class="token char">'\''</span> <span class="token operator">+</span>                <span class="token char">'&#125;'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>Class类常用方法如下<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> classAllPath <span class="token operator">=</span> <span class="token string">"com.yyh.class_.Animal"</span><span class="token punctuation">;</span><span class="token comment">//1. 获取到Animal类 对应的 Class对象</span><span class="token comment">//&lt;?>表示不确定的Java类型</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> cls <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>classAllPath<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 输出cls</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示cls的对象，是哪个Class对象 class com.yyh.class_.Animal</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出cls的运行类型 class java.lang.Class</span><span class="token comment">//3. 得到包名</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span><span class="token function">getPackage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4. 得到全类名</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 通过clas创建对象实例</span><span class="token class-name">Animal</span> cat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Animal</span><span class="token punctuation">)</span>cls<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6. 通过反射获取属性name</span><span class="token class-name">Field</span> name <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果name这里是私有属性或者default属性都会报错NoSuchFileException</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//7. 通过反射给属性赋值</span>name<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cat<span class="token punctuation">,</span><span class="token string">"HelloKitty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出HelloKitty</span><span class="token comment">//8. 遍历得到所有的字段属性</span><span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Field</span> f <span class="token operator">:</span> fields<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处只输出public属性</span>    <span class="token comment">/*输出:    name    age    home*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="获取Class对象的六种方法"><a href="#获取Class对象的六种方法" class="headerlink" title="获取Class对象的六种方法"></a>获取Class对象的六种方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1. Class.forName</span>        <span class="token class-name">String</span> classAllPath <span class="token operator">=</span> <span class="token string">"com.yyh.class_.Animal"</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> cls1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>classAllPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2. 类名.class，应用场景：参数传递</span>        <span class="token class-name">Class</span> cls2 <span class="token operator">=</span> <span class="token class-name">Animal</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cls2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 对象.getClass()，应用场景：有对象实例</span>        <span class="token comment">//反映了 反射 的本质，即程序在运行期可以得到一个对象的所有信息，这个信息里面就包括了对象对应的类的信息</span>        <span class="token class-name">Animal</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">></span></span> cls3 <span class="token operator">=</span> cat<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cls3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4. 通过类加载器来获取到类的Class对象</span>        <span class="token comment">//(1)先得到类加载器 car</span>        <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> cat<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//(2)通过类加载器得到Class对象</span>        <span class="token class-name">Class</span> cls4 <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>classAllPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cls4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//cls1,cls2,cls3,cls4其实是同一个对象</span>        <span class="token comment">//5. 基本数据类型（int,char,bytr,long......）按如下方式得到Class类对象</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> integerClass <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integerClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//int</span>        <span class="token comment">//6. 基本数据类型对应的包装类，可以通过.TYPE得到Class类对象</span>        <span class="token class-name">Class</span> type <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//int</span>        <span class="token comment">//integerClass和type实际上也是同样的类，底层会进行自动装箱和自动拆箱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git相关命令</title>
      <link href="/2022/02/06/git-xiang-guan-ming-ling/"/>
      <url>/2022/02/06/git-xiang-guan-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="SSH密钥文件"><a href="#SSH密钥文件" class="headerlink" title="SSH密钥文件"></a>SSH密钥文件</h2><p>Github里面S设置SH公钥有两者选择方式</p><ol><li>账号下的每个仓库都设置一个公钥，因为GitHub官方要求每个仓库的公钥都不能相同，所以每个账号都要搞一个密钥（很麻烦）</li><li>给账号分配一个公钥，然后这个公钥就可以在这个账号下的每个仓库中使用（推荐）</li></ol><p>生成密钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"your_email@youremail.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证密钥是否添加成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="本地仓库处理"><a href="#本地仓库处理" class="headerlink" title="本地仓库处理"></a>本地仓库处理</h2><p>创建仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将文件添加到仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将文件提交到仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">"message"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改最新提交的commit</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit --amend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>回滚到特定版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> reset --hard HEAD^<span class="token comment">#回滚到上一版本</span><span class="token function">git</span> reset --hard HEAD~3<span class="token comment">#回滚到3次版本之前，以此类推可回到n次版本之前</span><span class="token function">git</span> reset --hard commit_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看仓库当前状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更改分支名称</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch -m oldNme newName<span class="token comment">#一般都是要 git branch -m master main </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="远程仓库处理"><a href="#远程仓库处理" class="headerlink" title="远程仓库处理"></a>远程仓库处理</h2><p>删除远程分支（注意主分区无法删除，如果需要删除的话要在github的setting里面切换主分支）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push --delete origin oldName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>克隆仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token operator">&lt;</span>repo<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接远程仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:yourName/repositoryname.gitor<span class="token function">git</span> remote <span class="token function">add</span> origin https://github.com/yourName/repositoryname.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从远程仓库pull到本地仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> pull origin main//因为黑命贵，所以master改main了。。。。这里好坑<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建仓库pull的时候可能会出现</p><div align=center><img src=https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20231106212516.png width=100%></div><p>这种情况使用<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> pull origin main --allow-unrelated-histories<span class="token comment">#不管历史情况强行合并</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>从本地push到远程仓库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建仓库的时候可能会出现如下错误</p><div align=center><img src=https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/vscode/20231106212351.png width=100%></div><p>这种情况使用<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin main -f <span class="token comment">#强行push</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><p>当文件已经提交后才记起来没有写.gitignore文件的处理方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> -r --cache <span class="token builtin class-name">.</span> <span class="token comment">#不要忘了后面的那个"."</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">"重新添加.gitignore文件"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="git-rebase命令"><a href="#git-rebase命令" class="headerlink" title="git rebase命令"></a>git rebase命令</h2><p>情景再现：commit太多次，想要将其合并（广义上的删除）</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220330234049303.png" alt="如图，共有4此提交" style="zoom: 67%;" /></p><p>用<code>git log</code>命令可以看到，共有4次提交，想要合并其中的“增加4.1和4.2文件”和“加入3.1和3.2文件”，将其表达为“增加3.1，3.2，4.1，4.2文件”。（可以使用<code>git log --pretty=oneline</code>命令让commit一行一行输出）</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> rebase -i commit_id<span class="token punctuation">(</span>commit_id只需要简写前面六位字母即可，不需要全部填上去<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令的<code>commit_id</code>表示的是将其前面的<code>commi_id</code>列入编辑状态，例如此处我输入<code>git rebase -i 88480a</code>，则可以对<code>411b01</code>、<code>5a9bb6</code>和<code>8f0dd1</code>这三个commit进行编辑。（也就是说分支最少会剩余2个commit）</p><p>进入编辑页面</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220331003630124.png" alt="image-20220331003630124" style="zoom:67%;" /></p><p>前缀的意思：</p><ol><li><code>pick</code>保留该commit，缩写：<code>p</code></li><li><code>squash</code>使用该commit但是<strong>合并</strong>到前一个<strong>老</strong>的commit之中去，缩写：<code>s</code>，在某种意义上来说就是删除。该步骤结束后会弹出窗口对合并后的commit进行编辑</li><li><code>reword</code>类似于<code>pick</code>，但是会弹出窗口，可以修改commit的信息，缩写：<code>r</code></li><li><code>edit</code>类似于<code>reword</code>可以修改commit，会将commit的修改放置在接下来的amending中，也比较方便，缩写：<code>e</code></li><li><code>fixup</code>和<code>squash</code>类似，但是会直接舍弃其commit信息，缩写：<code>f</code></li><li><code>exec</code>执行shell命令（没用过）</li><li><code>drop</code>删除某一commit</li></ol><p>此处将“增加4.1和4.2文件”前的<code>pick</code>更改为<code>squash</code>（<code>fixup</code>也可以，就不会弹出窗口了），关闭编辑器，会弹出以下窗口</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220331111257663.png" alt="image-20220331111257663" style="zoom:67%;" /></p><p>默认最后的commit会有两个合并的commit共同组成，也可以在这里进行修改，例如我改成这样一行显示的：</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220331111455061.png" alt="image-20220331111455061" style="zoom:67%;" /></p><p>合并结果就会变成</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220331111542047.png" alt="image-20220331111542047" style="zoom:80%;" /></p><p><strong>PS</strong>：每次操作之后记得都要<code>ctrl+s</code>保存</p><h3 id="关于noop"><a href="#关于noop" class="headerlink" title="关于noop"></a>关于noop</h3><p>当我们选取了最新的commit之后，就会显示noop，表示在这之前没有更新的commit可供操作，例如在本例中我输入<code>git rebase -i fb083c</code>，则会显示noop：</p><p><img src="http://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/img/image-20220331111830269.png" alt="image-20220331111830269" style="zoom:80%;" /></p><h2 id="有关报错的处理方式"><a href="#有关报错的处理方式" class="headerlink" title="有关报错的处理方式"></a>有关报错的处理方式</h2><h3 id="unable-to-auto-detect-email-address"><a href="#unable-to-auto-detect-email-address" class="headerlink" title="unable to auto-detect email address"></a>unable to auto-detect email address</h3><p><img src="https://yyh-blogimage.oss-cn-shanghai.aliyuncs.com/en-us_image_0000001645684408.png" alt="en-us_image_0000001645684408"></p><p>原因是未设置email地址，解决方式其实上面已经给出了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">""</span><span class="token function">git</span> config --global user.email <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
